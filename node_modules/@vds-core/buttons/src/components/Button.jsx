import React from 'react';
import PropTypes from 'prop-types';
import styled, { css } from 'styled-components';
import { calculateRem } from '@uie/javascript-style-helpers';
import { TitleConfig, TypographyConfig } from '@vds-core/typography';
import { colors } from '@vds-core/theme';

function _calculateButtonHeight(size) {
  let height;
  if (size === 'small') {
    height = calculateRem(24);
  } else {
    height = calculateRem(42);
  }
  return height;
}

function _calculateSideMargin(size, width) {
  let sideMargin;
  if (size === 'small') {
    sideMargin = width === 'autoTight' ? 12 : 24;
  } else {
    sideMargin = width === 'autoTight' ? 21 : 42;
  }
  return calculateRem(sideMargin);
}

const fontWeightStrong = 750;

const propTypes = {
  /**
   * Decides if the button is rendered as primary (will default as primary).
   */
  primary: PropTypes.bool,
  /**
   * Decides if the button is rendered as secondary.
   */
  secondary: PropTypes.bool,
  /** String value for inner button text. */
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.string]),
  /** Button will be disabled if disabled prop is passed. */
  disabled: PropTypes.bool,
  /** Function for handling click events */
  onClick: PropTypes.func,
  /** The size of the button. */
  size: PropTypes.oneOf(['normal', 'tiny', 'small', 'large', 'block']),
  /** does the button have a fixed or variable width */
  width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  /** DEPRECATED SIZES: normal, tiny, block **/

  display: PropTypes.oneOf(['flex', 'inline-block', 'block']),

  ariaLabel: PropTypes.string,
  /**
   * @ignore
  Object containg font styles, including font-size, line-height, and font-family */
  bodyConfig: PropTypes.object,
  /**
   * @ignore
  Typescale of button text */
  typescale: PropTypes.string,
  /**
   * @ignore
  Object containing colors in hex */
  colorConfig: PropTypes.object,
  /**
   * @ignore
  Boolean that turns on new focus state */
  focusState: PropTypes.bool,
  /**
   * @ignore
  Boolean that turns on new hover state */
  hoverState: PropTypes.bool,
  /**
   * @ignore
  Boolean that turns on new active state */
  activeState: PropTypes.bool,
  /**
   * @ignore
  Boolean that activates hit area */
  hitArea: PropTypes.bool,
  /**
   * @ignore
  Prop that determines Button height */
  calculateButtonHeight: PropTypes.func,
  /**
   * @ignore
  Prop that determines the margin size on each side of text */
  calculateSideMargin: PropTypes.func,
  /**
   * @ignore
  Boolean that turns on/off vertical padding on small button text */
  smallButtonPadding: PropTypes.bool,
  /**
   * @ignore
  If provided, text will overflow with ellipsis */
  overflowEllipsis: PropTypes.bool,
  /**
   * @ignore
  If provided, the number given will determine the font weight */
  calculateFontWeight: PropTypes.number,
  /**
   * Allows a string to be provided for analytics.
   */
  'data-analyticstrack': PropTypes.string,
  /**
   * Allows a string to be provided for analytics.
   */
  'data-track': PropTypes.string,
  /**
   * Allows a string to be provided for click stream.
   */
  'data-clickstream': PropTypes.string,
  /**
   * @ignore
   */
  dataLoc: PropTypes.string,
  /**
   * If provided, button primitive becomes an anchor, with the given href attribute.
   */
  href: PropTypes.string,
};

const defaultProps = {
  primary: false,
  secondary: false,
  children: null,
  disabled: false,
  size: 'large',
  display: 'flex',
  width: 'auto',
  onClick: undefined,
  bodyConfig: TitleConfig,
  colorConfig: colors,
  hitArea: false,
  calculateButtonHeight: _calculateButtonHeight,
  calculateSideMargin: _calculateSideMargin,
  hoverState: false,
  smallButtonPadding: true,
  overflowEllipsis: false,
  calculateFontWeight: fontWeightStrong,
  typescale: TypographyConfig.getTypescale(),
};

/**
 * @component
 * */

/*
fontWeightStrong represents the font weight found in 
typography used when the component is bolded. Font weight is
not exported by typography configs due to the fact that 
typography components may have multiple font weight options
*/

const HitArea = styled.span`
  height: ${calculateRem(44)};
  width: 100%;
  left: 50%;
  position: absolute;
  transform: translate(-50%, -50%);
  text-align: center;
  top: 50%;
  content: '';
  display: inline-block;
  &:hover {
    cursor: pointer;
  }
`;

const StyledChildWrapper = styled.span`
  position: relative;
  height: 100%;
  width: 100%;
  border-radius: ${calculateRem(100)};
  box-sizing: border-box;
  display: flex;
  align-items: center;
  background: transparent;
  justify-content: center;
  text-overflow: ${({ overflowEllipsis }) => overflowEllipsis && 'ellipsis'};
  &:focus {
    outline: none;
  }
  ${({ size, width, calculateSideMargin, smallButtonPadding }) => {
    if (size === 'block') return `margin: auto`;
    switch (size) {
      case 'tiny':
        return `
          margin: ${calculateRem(0, 13)};
        `;
      case 'small':
        return `
          padding-right: ${calculateSideMargin(size, width)};
          padding-left: ${calculateSideMargin(size, width)};
          padding: ${({ smallButtonPadding }) =>
            smallButtonPadding ? calculateRem(6.5, 0) : 0};
        `;
      case 'block':
        return `
          display: block;
          width: 100%;
          padding-right: ${calculateRem(width === 'autoTight' ? 21 : 42)};
          padding-left: ${calculateRem(width === 'autoTight' ? 21 : 42)};
        `;
      default:
        return `
          padding-right: ${calculateSideMargin(size, width)};
          padding-left: ${calculateSideMargin(size, width)};`;
    }
  }};
  &:hover {
    outline: none;
    border: none;
  }
`;

const findWidth = width => {
  if (typeof width === 'string') return width;
  return calculateRem(width);
};

const buttonStyles = css`
  padding: 0;
  border-radius: ${calculateRem(100)};
  border-width: ${calculateRem(1)};
  box-sizing: border-box;
  cursor: pointer;
  display: ${({ display }) => display};
  flex-direction: row;
  align-items: center;
  justify-content: center;
  font-family: ${({ largeButtonText }) => largeButtonText.fontFamily};
  font-size: ${({ largeButtonText }) => calculateRem(largeButtonText.fontSize)};
  font-weight: ${({ calculateFontWeight }) => calculateFontWeight};
  line-height: ${({ largeButtonText }) =>
    calculateRem(largeButtonText.lineHeight)};
  letter-spacing: ${({ largeButtonText, size }) =>
    size === 'large' && calculateRem(largeButtonText.letterSpacing)};
  height: ${({ calculateButtonHeight, size }) => calculateButtonHeight(size)};
  position: relative;
  text-align: center;
  text-decoration: none;
  touch-action: manipulation;
  vertical-align: middle;
  width: auto;
  overflow: visible;

  ${({ size, width, smallButtonText }) => {
    if (size === 'tiny') {
      return `
        font-size: ${calculateRem(smallButtonText.fontSize)};
        line-height: ${calculateRem(smallButtonText.lineHeight)};
        font-family: ${smallButtonText.fontFamily};
      `;
    }

    if (size === 'small') {
      return `
        font-size: ${calculateRem(smallButtonText.fontSize)};
        line-height: ${calculateRem(smallButtonText.lineHeight)};
        font-family: ${smallButtonText.fontFamily};
        width: ${width ? findWidth(width) : 'auto'};
        white-space: nowrap;
      `;
    }

    if (size === 'large') {
      return `
        width: ${width ? findWidth(width) : 'auto'};
        white-space: nowrap;
      `;
    }

    if (size === 'block') {
      return `
        display: block;
        width: 100%;
      `;
    }
  }};

  background-color: ${({ colorConfig, secondary }) =>
    secondary ? 'transparent' : colorConfig.black};
  border: ${({ colorConfig }) =>
    `${calculateRem(1)} solid ${colorConfig.black}`};
  color: ${({ colorConfig, secondary }) =>
    secondary ? colorConfig.black : colorConfig.white};
  ${({ activeState, disabled, colorConfig }) =>
    activeState &&
    !disabled &&
    `
      &:active {
        border-color: ${colorConfig.coolGray6};
        box-shadow: 0 0 0 ${calculateRem(1)} ${colorConfig.coolGray6};
        background-color: ${colorConfig.coolGray6};
      }
    `};
  ${({ focusState, disabled, inverted, colorConfig }) =>
    focusState &&
    !disabled &&
    `
     &:focus:not(:hover) {
      outline: none;
      &::before {
        border: ${calculateRem(1)} dashed ${
      inverted ? colorConfig.white : colorConfig.black
    };
        border-radius: ${calculateRem(100)};
        content: '';
        height: calc(100% + ${calculateRem(6)});
        left: 50%;
        position: absolute;
        top: 50%;
        transform: translate(-50%, -50%);
        width: calc(100% + ${calculateRem(6)});
      }
    }
    `};
  ${({ hoverState, colorConfig, inverted, disabled }) =>
    hoverState &&
    !disabled &&
    `
    &:hover:not(:active) {
      outline: none;
      box-shadow: 0 0 0 ${calculateRem(1)} ${
      inverted ? colorConfig.white : colorConfig.black
    };
      transition: ease-out 0.1s;
    }
    &:hover:not(:active) span {
      border: none;
    }
  `};

  ${({ inverted, disabled, activeState, colorConfig, secondary }) =>
    inverted &&
    !disabled &&
    `
    background-color: ${secondary ? 'transparent' : colorConfig.white};
    border: ${calculateRem(1)} solid ${colorConfig.white};
    color: ${secondary ? colorConfig.white : colorConfig.black};

  `};

  ${({ disabled, colorConfig, activeState, secondary }) =>
    disabled &&
    `
    background-color: ${secondary ? 'transparent' : colorConfig.coolGray3};
    border-color: ${colorConfig.coolGray3};
    color: ${secondary ? colorConfig.coolGray3 : colorConfig.white}
    cursor: default;
  `};

  ${({ disabled, inverted, colorConfig, activeState, secondary }) =>
    disabled &&
    inverted &&
    `
    background-color: ${secondary ? 'transparent' : colorConfig.coolGray10};
    border-color: ${colorConfig.coolGray10};
    color: ${secondary ? colorConfig.coolGray10 : colorConfig.black}
  `};
`;

const StyledButton = styled.button`
  ${buttonStyles};
`;

const StyledAnchor = styled.a`
  ${buttonStyles};
  width: ${({ width, size }) =>
    width !== 'auto' && width !== 'autoTight' && size === 'large'
      ? findWidth(width)
      : 'fit-content'};
  justify-content: center;
`;

/**
 * @ignore
 */
const Button = props => {
  const {
    children,
    size,
    width,
    disabled,
    ariaLabel,
    onClick,
    display,
    colorConfig,
    bodyConfig,
    hitArea,
    typescale,
    calculateButtonHeight,
    calculateSideMargin,
    smallButtonPadding,
    calculateFontWeight,
    overflowEllipsis,
    dataLoc,
    secondary,
    href,
  } = props;

  let largeButtonText, smallButtonText;
  largeButtonText = bodyConfig.getStyles(
    typescale,
    'desktop',
    typescale === 'VDS' ? 'large' : 'extraSmall'
  );
  smallButtonText = bodyConfig.getStyles(
    typescale,
    'mobile',
    typescale === 'VDS' ? 'small' : 'extraSmall'
  );

  let newAriaLabel = ariaLabel
    ? ariaLabel
    : typeof children === 'string'
    ? children
    : 'Button';

  let ButtonBase = href ? StyledAnchor : StyledButton;

  return (
    <ButtonBase
      {...props}
      href={href}
      size={size}
      width={width}
      aria-label={newAriaLabel}
      role="button"
      aria-disabled={props.disabled}
      tabIndex={0}
      display={display}
      largeButtonText={largeButtonText}
      smallButtonText={smallButtonText}
      colorConfig={colorConfig}
      disabled={disabled}
      calculateButtonHeight={calculateButtonHeight}
      calculateSideMargin={calculateSideMargin}
      calculateFontWeight={calculateFontWeight}
      data-loc={dataLoc}
      secondary={secondary}
    >
      {hitArea && !disabled && <HitArea />}
      <StyledChildWrapper
        tabIndex={-1}
        display={display}
        size={size}
        width={width}
        overflowEllipsis={overflowEllipsis}
        calculateSideMargin={calculateSideMargin}
        smallButtonPadding={smallButtonPadding}
      >
        {children}
      </StyledChildWrapper>
    </ButtonBase>
  );
};

Button.defaultProps = defaultProps;
Button.propTypes = propTypes;

/** @component */
export default Button;
