import * as React from 'react';
import { Fragment, Component } from 'react';
import { calculateRem } from '@uie/javascript-style-helpers';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import ButtonGroupItem from './ButtonGroupItem';
import { withVDSManager } from '@vds-core/utilities';

const propTypes = {
  /**
   * If provided, Button components will be rendered based on this data
   */
  data: PropTypes.array.isRequired,
  /**
   * If provided, width of Button components will be rendered based on this value. If omitted, default button widths are rendered.
   */
  childWidth: PropTypes.string,
  /**
   * An object containing number of Button components per row, in each viewport
   */
  rowQuantity: PropTypes.object,
  /**
   * Viewport the Buttons will be rendered in
   */
  viewport: PropTypes.oneOf(['desktop', 'tablet', 'mobile']),
  /**
   * @ignore
   * No vertical padding
   */
  noVerticalPadding: PropTypes.bool,
  /**
  * @ignore 
   If provided, the provided string will determine the spacing between small buttons
   */

  smallButtonSpacing: PropTypes.string,
  /**
  * @ignore
   If provided a max width of the provided string will be rendered.
  */
  maxWidth: PropTypes.string,
  /**
  * @ignore
   If provided a new Button component will render
  */
  renderButton: PropTypes.func,
  /**
   * @ignore
   */
  dataLoc: PropTypes.string,
};

const defaultProps = {
  childWidth: '100%',
  viewport: 'desktop',
  noVerticalPadding: false,
  maxWidth: undefined,
  smallButtonSpacing: '2X',
};

const ButtonGroupWrapper = styled.div`
  display: flex;
  flex-wrap: wrap;
  flex: 1;
  max-width: ${({ width, rowQuantity }) => rowQuantity !== 1 && width};
  width: 100%;
`;

function _calculateWidth(childWidth, maxWidth) {
  let width;
  let maximum = parseInt(maxWidth);
  if (childWidth[childWidth.length - 1] === '%') {
    width = parseInt(childWidth) / 100;
    width = calculateRem(596 * width);
  } else if (childWidth && parseInt(childWidth) < maximum) {
    width = calculateRem(parseInt(childWidth));
  } else {
    width = calculateRem(maximum);
  }
  return width;
}

class ButtonGroup extends Component {
  _onClick = (e, childClick) => {
    childClick && childClick(e);
    this.props.onClick && this.props.onClick(e);
  };

  render() {
    const {
      data,
      childWidth,
      rowQuantity: rowQuantityProp,
      viewport,
      noVerticalPadding,
      smallButtonSpacing,
      maxWidth,
      renderButton,
      dataLoc,
    } = this.props;
    const rowQuantityVal = rowQuantityProp
      ? rowQuantityProp[viewport]
      : data.length;

    return (
      <ButtonGroupWrapper
        childWidth={childWidth}
        viewport={viewport}
        maxWidth={maxWidth}
        width={_calculateWidth(childWidth, maxWidth)}
        rowQuantity={rowQuantityVal}
      >
        {data.map((child, index) => {
          const { children, size, type, width, noVerticalPadding } = child;
          let btnWidth = childWidth;
          btnWidth ? btnWidth : (btnWidth = width);
          return (
            <Fragment key={index}>
              <ButtonGroupItem
                {...child}
                children={children}
                rowQuantity={rowQuantityVal}
                size={size}
                type={type}
                width={btnWidth}
                onClick={e => this._onClick(e, child.onClick)}
                index={index}
                noVerticalPadding={noVerticalPadding}
                smallButtonSpacing={smallButtonSpacing}
                renderButton={renderButton}
                dataLoc={dataLoc}
              />
            </Fragment>
          );
        })}
      </ButtonGroupWrapper>
    );
  }
}

ButtonGroup.propTypes = propTypes;
ButtonGroup.defaultProps = defaultProps;

/** @component */
export default withVDSManager(ButtonGroup);
