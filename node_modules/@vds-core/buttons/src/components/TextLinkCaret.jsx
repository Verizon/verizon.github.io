import React, { Fragment } from 'react';
import styled, { css } from 'styled-components';
import PropTypes from 'prop-types';
import { calculateRem } from '@uie/javascript-style-helpers';
import { TitleConfig, TypographyConfig } from '@vds-core/typography';
import { colors, calculateSpacing } from '@vds-core/theme';
import Icon, { IconData } from '@vds-core/icons';

const propTypes = {
  /**
   * Determines <strong>icon position</strong> of Caret.
   */
  iconPosition: PropTypes.oneOf(['left', 'right']),
  /**
   * Determines size of the text and icon.
   */
  size: PropTypes.oneOf(['large', 'small']),
  /**
   *  This function will be called when the Button is clicked. It will return an event.
   */
  onClick: PropTypes.func,
  /**
   *  This string will be applied to the href attribute.
   */
  href: PropTypes.string,
  /**
   *  Button will be <strong>disabled</strong> if disabled prop is passed.
   */
  disabled: PropTypes.bool,
  /**
   *  Button will be displayed in <strong>inverted</strong> colors if inverted prop is passed.
   */
  inverted: PropTypes.bool,
  /**
   * Item to render as text link.
   */
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.string]),
  /**
   * If provided, used as string that labels the element for accessibility.
   */
  ariaLabel: PropTypes.string,
  /**
   * @ignore
  Font styles object of text containing font-size, line-height, font-family, and font-weight */
  fontConfig: PropTypes.object,
  /**
   * @ignore
  If passed, Icon component with new icon data will render */
  iconConfig: PropTypes.object,
  /**
   * @ignore
  Color object containing hex colors */
  colorConfig: PropTypes.object,
  /**
   * @ignore
  Boolean that turns on/off new hover styles */
  hoverState: PropTypes.bool,
  /**
   * @ignore
  Boolean that turns on/off new focus styles */
  focusState: PropTypes.bool,
  /**
   * @ignore
  Boolean that turns on/off new active styles */
  activeState: PropTypes.bool,
  /**
   * @ignore
  Boolean that turns on/off a hit area */
  hitArea: PropTypes.bool,
  /**
   * @ignore
  If passed, a new font weight will be passed to the text link text*/
  calculateFontWeight: PropTypes.number,
  /**
   * @ignore
  String that determines the typescale of the text link text */
  typescale: PropTypes.string,
  /**
   * @ignore
  Number that determines left or right padding on TextLinkCaret */
  padding: PropTypes.string,
  /**
   * Allows a string to be provided for analytics.
   */
  'data-analyticstrack': PropTypes.string,
  /**
   * Allows a string to be provided for analytics.
   */
  'data-track': PropTypes.string,
  /**
   * Allows a string to be provided for click stream.
   */
  'data-clickstream': PropTypes.string,
  /**
   * @ignore
   */
  dataLoc: PropTypes.string,
  /**
   * Allows a unique ID to be passed to the component.
   */
  id: PropTypes.string,
};

const defaultProps = {
  iconPosition: 'right',
  size: 'large',
  disabled: false,
  inverted: false,
  onClick: () => {},
  href: '',
  hoverState: false,
  focusState: false,
  activeState: false,
  fontConfig: TitleConfig,
  iconConfig: IconData,
  colorConfig: colors,
  hitArea: false,
  calculateFontWeight: undefined,
  typescale: TypographyConfig.getTypescale(),
  padding: '1X',
};

const Wrapper = styled.span`
  width: 100%;
  height: 100%;
  position: relative;
  display: inline-flex;
  &:focus {
    outline: none;
  }
`;

const StyledAnchor = styled.a`
  position: relative;
  width: fit-content;
  display: flex;
  align-items: ${({ iconPosition }) =>
    iconPosition && iconPosition === 'right' ? 'center' : 'flex-start'};
  padding-left: ${({ iconPosition, padding }) =>
    iconPosition === 'left' && padding !== '0' ? calculateSpacing(padding) : 0};
  padding-right: ${({ iconPosition, padding }) =>
    iconPosition === 'right' && padding !== '0'
      ? calculateSpacing(padding)
      : 0};
  border: 0;
  cursor: pointer;
  background-image: none;
  background-color: transparent;
  text-decoration: none;
  transition: opacity 0.15s ease-in;
  touch-action: manipulation;
  background-color: transparent;
  align-content: center;
  * {
    mouse-events: none;
    outline: none;
  }
  font-size: ${({ textLinkText }) => calculateRem(textLinkText.fontSize)};
  font-family: ${({ textLinkText }) => textLinkText.fontFamily};
  font-weight: ${({ textLinkText, calculateFontWeight }) =>
    calculateFontWeight ? calculateFontWeight : textLinkText.fontWeight};
  line-height: ${({ textLinkText }) => calculateRem(textLinkText.lineHeight)};
  letter-spacing: ${({ textLinkText }) =>
    textLinkText &&
    textLinkText.letterSpacing &&
    calculateRem(textLinkText.letterSpacing)};
  font-style: normal;
  color: ${({ colorConfig }) => colorConfig.black};

  ${({ inverted, colorConfig }) =>
    inverted &&
    `
    color: ${colorConfig.white};
    &:active {
      opacity: 0.77;
      transition: opacity .15s ease-out;
    }
  `}

  ${({ disabled, colorConfig }) =>
    disabled &&
    `
    pointer-events: none;
    cursor: not-allowed;
    color: ${colorConfig.coolGray3};
    &:hover {
      background-color: transparent;
    }
  `}

  ${({ disabled, inverted, colorConfig }) =>
    disabled &&
    inverted &&
    `
    color: ${colorConfig.coolGray10};
  `};

  ${({ focusState, colorConfig, inverted }) =>
    focusState &&
    `
     &:focus:not(:hover)  {
      outline: none;
      &::before {
        border: ${calculateRem(1)} dashed ${
      inverted ? colorConfig.white : colorConfig.black
    };
        content: '';
        height: calc(100% + ${calculateRem(6)});
        left: 50%;
        position: absolute;
        top: 50%;
        transform: translate(-50%, -50%);
        width: calc(100% + ${calculateRem(6)});
      }
    }
    &:focus {
      outline: none;
    }
  `};

  ${({ activeState, colorConfig }) =>
    activeState
      ? `
      &:active {
        outline: none;
        color: ${colorConfig.coolGray6};
      }

      &:active svg g path {
        stroke: ${colorConfig.coolGray6};
      }
    `
      : `
      &:active {
        opacity: 0.77;
        transition: opacity 0.15s ease-out;
      }
  `};

  ${({ hoverState, iconPosition }) =>
    hoverState &&
    ` 
      svg {
        left: 0;
        transition: ease-in-out .350s;
      }
      &:hover {
        outline: none;
      }
      &:hover svg {
        position: relative;
        left: ${
          iconPosition === 'right' ? calculateSpacing('1X') : calculateRem(-4)
        };
        transition: left .350s ease-in-out;
        transition-timing-function: cubic-bezier(0.22, 0.61, 0.36, 1.0);
      }

  `};
`;

const ContentWrapper = styled.span`
  display: flex;
  align-items: center;
  pointer-events: none;
`;

const HitArea = styled.span`
  cursor: pointer;
  display: inline-block;
  height: ${calculateRem(44)};
  left: 50%;
  position: absolute;
  text-align: center;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 100%;
`;

const AnchorContentWrapper = styled.span`
  display: inline-block;
  pointer-events: none;
`;

const TextWrapper = styled.span`
  display: inline-flex;
  pointer-events: none;
`;

const IconWrapper = styled.span`
  pointer-events: none;
  display: inline-flex;
  position: relative;
  height: ${({ textLinkText }) =>
    textLinkText && calculateRem(textLinkText.lineHeight)};
  min-width: ${({ typescale }) =>
    typescale === 'VDS' ? calculateRem(12) : calculateRem(16)};
  padding-left: ${({ iconPosition }) =>
    iconPosition === 'right' && calculateSpacing('1X')};
  padding-right: ${({ iconPosition }) =>
    iconPosition === 'left' && calculateSpacing('1X')};
  svg {
    position: relative;
    top: ${({ typescale, iconPosition }) =>
      iconPosition === 'right'
        ? typescale === 'VDS'
          ? '5px'
          : '-1px'
        : typescale === 'VDS'
        ? '4px'
        : '-2px'};
  }
`;

function _encodeInline(color) {
  if (!color) return '%23000000';
  var splitHex = color.split('#')[1];
  return '%23' + splitHex;
}

function iconColor(disabled, inverted, colors) {
  if (inverted && disabled) return colors.coolGray10;
  else if (inverted && !disabled) return colors.white;
  else if (!inverted && disabled) return colors.coolGray3;
  else return colors.black;
}

function _getBodyStyles({ size, typescale, config }) {
  let textLinkSize;
  switch (typescale) {
    case 'VDS':
      textLinkSize = size === 'small' ? 'small' : 'large';
      break;
    case 'MVP':
    default:
      textLinkSize = 'extraSmall';
      break;
  }
  return config.getStyles(typescale, 'desktop', textLinkSize);
}

function _formatChildren(childArray) {
  let textWithoutCaret = '';
  childArray.map((item, index) => {
    if (index !== childArray.length - 1) {
      textWithoutCaret += item + ' ';
    }
  });
  return textWithoutCaret;
}

function checkForNode(children) {
  let lastIndex = children.length - 1, //number of last index in child array
    lastChild = children[lastIndex], //last child in child array
    isNode = typeof children[lastIndex] !== 'string', //if last child is node
    isString = typeof children === 'string', //if children are a string
    firstNodes = [];

  if (children.length === undefined || children.length <= 1)
    return { childArray: [], textWithCaret: children }; //if only one child put with caret and return

  if (isNode || !isString) {
    //if the last child is node or mixture put last with the caret
    children.map((child, index) => {
      //add all children to first nodes except the last one
      if (index !== lastIndex) firstNodes[index] = child;
    });
    return { childArray: firstNodes, textWithCaret: lastChild };
  }
  //if all children are "strings", put last word with caret
  let childArray = children.split(' ');
  let textWithCaret = childArray[childArray.length - 1];
  return {
    childArray: _formatChildren(childArray),
    textWithCaret: textWithCaret,
  };
}

function _renderWithIcon(props, textLinkText, color) {
  const { iconConfig, iconPosition, colorConfig, typescale, children } = props;
  let childArray = children ? checkForNode(children).childArray : [];
  let textWithCaret = children ? checkForNode(children).textWithCaret : '';
  return (
    <Fragment>
      {iconPosition === 'left' && (
        <IconWrapper
          tabIndex={-1}
          iconPosition={iconPosition}
          typescale={typescale}
          textLinkText={textLinkText}
          aria-hidden={true}
        >
          <Icon
            name={`caret-${iconPosition}`}
            size={typescale === 'VDS' ? 'extraSmall' : 'small'}
            color={color}
            colorConfig={colorConfig}
            data={iconConfig}
            iconPosition={iconPosition}
            hasStroke
            medium
            tabIndex={-1}
            aria-hidden={true}
          />
        </IconWrapper>
      )}
      <AnchorContentWrapper tabIndex={-1}>
        {childArray}
        <TextWrapper>
          {textWithCaret}
          {iconPosition === 'right' && (
            <IconWrapper
              textLinkText={textLinkText}
              tabIndex={-1}
              typescale={typescale}
              iconPosition={iconPosition}
              aria-hidden={true}
            >
              <Icon
                name={`caret-${iconPosition}`}
                size={typescale === 'VDS' ? 'extraSmall' : 'small'}
                color={color}
                colorConfig={colorConfig}
                data={iconConfig}
                iconPosition={iconPosition}
                hasStroke
                medium
                tabIndex={-1}
                aria-hidden={true}
              />
            </IconWrapper>
          )}
        </TextWrapper>
      </AnchorContentWrapper>
    </Fragment>
  );
}

const TextLinkCaret = props => {
  const {
    iconPosition,
    size,
    fontConfig,
    colorConfig,
    typescale,
    hitArea,
    hoverState,
    focusState,
    activeState,
    calculateFontWeight,
    padding,
    dataLoc,
  } = props;

  const Typescale = typescale ? typescale : TypographyConfig.getTypescale();
  const textLinkText = _getBodyStyles({
    config: fontConfig,
    typescale: Typescale,
    size,
  });

  const color = iconColor(props.disabled, props.inverted, colorConfig);

  return (
    <StyledAnchor
      {...props}
      data-testid="TextLinkCaret"
      data-loc={dataLoc}
      href={props.href}
      disabled={props.disabled}
      inverted={props.inverted}
      theme={props.theme}
      role="link"
      aria-disabled={props.disabled}
      tabIndex={0}
      aria-label={
        props.ariaLabel
          ? props.ariaLabel
          : props.children && typeof props.children === 'string'
          ? props.children
          : 'Text Link Caret'
      }
      hoverState={hoverState}
      focusState={focusState}
      activeState={activeState}
      iconPosition={iconPosition}
      padding={padding}
      textLinkText={textLinkText}
      colorConfig={colorConfig}
      calculateFontWeight={calculateFontWeight}
      tabIndex={props.disabled ? -1 : 0}
    >
      {hitArea && <HitArea tabIndex={-1} />}
      <Wrapper tabIndex={-1}>
        {_renderWithIcon(props, textLinkText, color)}
      </Wrapper>
    </StyledAnchor>
  );
};

TextLinkCaret.defaultProps = defaultProps;
TextLinkCaret.propTypes = propTypes;

export default TextLinkCaret;
