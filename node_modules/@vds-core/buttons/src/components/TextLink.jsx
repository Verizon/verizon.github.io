import React from 'react';
import styled, { css } from 'styled-components';
import PropTypes from 'prop-types';
import { calculateRem } from '@uie/javascript-style-helpers';
import { BodyConfig, TypographyConfig } from '@vds-core/typography';
import { colors } from '@vds-core/theme';
import { withVDSManager } from '@vds-core/utilities';

const propTypes = {
  /**
   * Determines display layout of button.
   */
  type: PropTypes.oneOf(['inline', 'standAlone']),
  /**
   * Determines <strong>viewport</strong> of button. Desktop and tablet are the same size.
   */
  viewport: PropTypes.oneOf(['mobile', 'tablet', 'desktop']),
  /**
   * Item to render as text link.
   */
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.string]),
  /**
   * Button will be disabled if <code>disabled</code> prop is passed.
   */
  disabled: PropTypes.bool,
  /**
   * Button will be displayed in Inverted colors if <code>inverted</code> prop is passed.
   */
  inverted: PropTypes.bool,
  /**
   *	This function will be called when the Button is clicked. It will return an event.
   */
  onClick: PropTypes.func,
  /**
   * This string will be applied to the href attribute.
   */
  href: PropTypes.string,
  /**
   * Determines color of <code>TextLink</code> text.
   */
  color: PropTypes.oneOf([colors.blue, colors.black]),
  /**
   * Button text will be <strong>bold</strong> if <code>bold</code> is set to true.
   */
  bold: PropTypes.bool,
  /**
   *	If provided, used as string that labels the element for accessibility.
   */
  ariaLabel: PropTypes.string,
  /**
   * @ignore
   */
  focusState: PropTypes.bool,
  /**
   * @ignore
   */
  activeState: PropTypes.bool,
  /**
   * @ignore
   */
  hitArea: PropTypes.bool, //turns hit area on or off
  /**
   * @ignore
   */
  bodyConfig: PropTypes.object,
  /**
   * @ignore
   */
  colorConfig: PropTypes.object,
  /**
   * @ignore
   */
  typescale: PropTypes.string,
  /**
   * @ignore
   */
  size: PropTypes.oneOf(['small', 'large']),
  /**
   * Allows a string to be provided for analytics.
   */
  'data-analyticstrack': PropTypes.string,
  /**
   * Allows a string to be provided for analytics.
   */
  'data-track': PropTypes.string,
  /**
   * Allows a string to be provided for click stream.
   */
  'data-clickstream': PropTypes.string,
  /**
   * @ignore
   */
  dataLoc: PropTypes.string,
  /**
   * Allows a unique ID to be passed to the component.
   */
  id: PropTypes.string,
};

const defaultProps = {
  size: undefined,
  viewport: 'desktop',
  type: 'inline',
  disabled: false,
  inverted: false,
  onClick: undefined,
  bold: false,
  color: colors.primary,
  colorConfig: colors,
  typescale: TypographyConfig.getTypescale(),
  focusState: false,
  hitArea: false,
  bodyConfig: BodyConfig,
  tabIndex: 0,
  activeState: false,
};

const sharedHitAreaStyles = css`
  left: 50%;
  position: absolute;
  transform: translate(-50%, -50%);
  text-align: center;
  box-sizing: content-box;
  &:hover {
    cursor: pointer;
  }
  top: 50%;
  outline: none;
`;

const HitArea = styled.span`
  ${sharedHitAreaStyles}
  height: ${({ type }) =>
    type === 'inline' ? calculateRem(24) : calculateRem(44)};
  cursor: pointer;
  display: inline;
  width: 100%;
`;

const Wrapper = styled.span`
  height: ${({ type, bodyLarge }) =>
    type === 'inline' ? 'inherit' : calculateRem(bodyLarge.lineHeight)};
  width: 100%;
  position: relative;
  &:focus {
    outline: none;
  }
`;

const StyledAnchor = styled.a`
  width: auto;
  display: inline-block;
  position: relative;
  border: 0;
  cursor: pointer;
  background-image: none;
  background-color: transparent;
  text-decoration: none;
  font-size: ${({ type, bodyLarge }) =>
    type === 'inline' ? 'inherit' : calculateRem(bodyLarge.fontSize)};
  font-family: ${({ type, bodyLarge }) =>
    type === 'inline' ? 'inherit' : bodyLarge.fontFamily};
  font-weight: ${({ type, bold, bodyLarge }) =>
    bold ? '750' : type === 'inline' ? 'inherit' : bodyLarge.fontWeight};
  line-height: ${({ type, bodyLarge }) =>
    type === 'inline' ? 'inherit' : calculateRem(bodyLarge.lineHeight)};
  height: ${({ type, bodyLarge }) =>
    type === 'inline' ? 'inherit' : calculateRem(bodyLarge.lineHeight)};
  letter-spacing: ${({ type, bodyLarge }) =>
    type === 'inline'
      ? 'inherit'
      : bodyLarge.letterSpacing && calculateRem(bodyLarge.letterSpacing)};
  color: ${({ color }) => color};
  border-bottom: ${calculateRem(1)} solid;
  border-color: ${({ color }) => color};
  box-sizing: border-box;
  transition: opacity 0.15s ease-in;
  touch-action: manipulation;
  ${({ focusState, colors }) =>
    focusState &&
    `
     &:focus:not(:hover) {
      outline: none;
      &::after {
        box-sizing: border-box;
        border: ${calculateRem(1)} dashed ${colors.black};
        content: '';
        left: 50%;
        position: absolute;
        top: calc(50% + ${calculateRem(1)});
        transform: translate(-50%, -50%);
        height: calc(100% + ${calculateRem(6)});
        width: calc(100% + ${calculateRem(6)});
      }
    }
    &:hover {
      color: ${colors.blue};
      border-bottom: ${calculateRem(1)} solid ${colors.blue};
    }
    &:active {
      color: ${colors.coolGray6};
      border-bottom: ${calculateRem(1)} solid ${colors.coolGray6};
    }
    &:visited {
      outline: none;
    }
  `};

  ${({ focusState, colors }) =>
    !focusState &&
    `
      padding: ${calculateRem(0, 0, 1, 0)};
      &:hover,
      &:active,
      &:visited {
        outline: none;
      }

      &:active {
        opacity: 0.77;
        transition: opacity 0.15s ease-out;
      }

      &:hover {
        color: ${colors.blue};
        border-bottom: ${calculateRem(1)} solid ${colors.blue};
      }
    `};

  ${({ viewport, type, bodySmall, size }) =>
    (viewport === 'mobile' || size === 'small') &&
    type !== 'inline' &&
    `
      font-size: ${calculateRem(bodySmall.fontSize)};
      font-family: ${bodySmall.fontFamily};
      font-weight: ${bodySmall.fontWeight};
      line-height: ${calculateRem(bodySmall.lineHeight)}
      letter-spacing: normal;
    `};

  ${({ inverted, color, colors, focusState }) =>
    inverted &&
    !focusState &&
    `
      color: ${color && color !== colors.black ? color : colors.white};
      border-bottom: ${calculateRem(1)} solid ${
      color && color !== colors.black ? color : colors.white
    };
      &:active {
        opacity: 0.77;
        transition: opacity .15s ease-out;
      }`};

  ${({ inverted, color, colors, focusState }) =>
    inverted &&
    focusState &&
    `
      color: ${color && color !== colors.black ? color : colors.white};
      border-bottom: ${calculateRem(1)} solid ${
      color && color !== colors.black ? color : colors.white
    };
     &:focus:not(:hover) {
      outline: none;
      &::after {
        box-sizing: border-box;
        border: ${calculateRem(1)} dashed ${colors.white};
        content: '';
        left: 50%;
        position: absolute;
        top: calc(50% + ${calculateRem(1)});
        transform: translate(-50%, -50%);
        height: calc(100% + ${calculateRem(6)});
        width: calc(100% + ${calculateRem(6)});
      }
    }
      &:hover {
        color: ${colors.blueInverted};
        outline: none;
        border-bottom: ${calculateRem(1)} solid ${colors.blueInverted};
      }
      &:hover {
        color: ${colors.blueInverted};
        border-bottom: ${calculateRem(1)} solid ${colors.blueInverted};
      }
      &:active {
        color: ${colors.coolGray6};
        border-bottom: ${calculateRem(1)} solid ${colors.coolGray6};
      }
      `};

  ${({ disabled, colors }) =>
    disabled &&
    `
    pointer-events: none;
    cursor: not-allowed;
    color: ${colors.coolGray3};
    border-bottom: ${calculateRem(1)} solid ${colors.coolGray3};
    &:hover {
      background-color: transparent;
      color: ${colors.coolGray3};
      border-bottom: ${calculateRem(1)} solid ${colors.coolGray3};
    }
    &: focus{
      outline: none;
    }
  `};

  ${({ disabled, inverted }) =>
    disabled &&
    inverted &&
    `
    border-bottom: ${calculateRem(1)} solid ${colors.coolGray10};
    color: ${colors.coolGray10};
    
  `};

  ${({ activeState, color }) =>
    activeState &&
    `
    color: ${colors.coolGray6} !important;
    border-bottom: ${calculateRem(1)} solid ${colors.coolGray6} !important;
  `}
  &:focus {
    outline: none;
  }
`;

const TextLink = props => {
  const {
    focusState,
    hitArea,
    bodyConfig,
    colorConfig,
    typescale,
    activeState,
    id,
    disabled,
    dataLoc,
  } = props;
  let newAriaLabel = props.ariaLabel
    ? props.ariaLabel
    : props.children && typeof props.children === 'string'
    ? props.children
    : 'Text Link';

  const smallFontSize = typescale === 'VDS' ? 'small' : 'medium';
  const largeFontSize = typescale === 'VDS' ? 'large' : 'medium';
  const bodyLarge = bodyConfig.getStyles(typescale, 'desktop', largeFontSize);
  const bodySmall = bodyConfig.getStyles(typescale, 'mobile', smallFontSize);

  return (
    <StyledAnchor
      {...props}
      id={id}
      size={props.size}
      colors={colorConfig}
      type={props.type}
      viewport={props.viewport}
      disabled={props.disabled}
      inverted={props.inverted}
      href={props.href}
      color={props.color}
      bold={props.bold}
      aria-label={newAriaLabel}
      role="link"
      aria-disabled={props.disabled}
      tabIndex={props.disabled ? -1 : 0}
      focusState={focusState}
      bodySmall={bodySmall}
      bodyLarge={bodyLarge}
      activeState={activeState}
      data-loc={dataLoc}
    >
      {hitArea && <HitArea type={props.type} tabIndex={-1} />}
      <Wrapper
        colors={props.color}
        tabIndex={-1}
        type={props.type}
        bodyLarge={bodyLarge}
      >
        {props.children}
      </Wrapper>
    </StyledAnchor>
  );
};

TextLink.defaultProps = defaultProps;
TextLink.propTypes = propTypes;

export default withVDSManager(TextLink);
