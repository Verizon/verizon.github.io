import React from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import { calculateRem } from '@uie/javascript-style-helpers';
import Icon from '@vds-core/icons';
import { colors } from '@vds-core/theme';
import { withVDSManager } from '@vds-core/utilities';
import ProgressIndicator from './ProgressIndicator';
import CarouselBars from './CarouselBars';

const propTypes = {
  /**
   * Cards rendered in the Carousel.
   */
  children: PropTypes.node.isRequired,
  /**
   * Viewport the Carousel will be rendered in.
   */
  viewport: PropTypes.oneOf(['desktop', 'tablet', 'mobile']),
  /**
   * Specifies positioning of the ProgressIndicator on the Card.
   */
  autoplayIndicatorPosition: PropTypes.oneOf(['left', 'right', 'hidden']),
  /**
   * Invert the color scheme of the Carousel.
   */
  inverted: PropTypes.bool,
  /**
   *  Unique identifier value for 'aria-controls'.
   */
  uniqueId: PropTypes.string.isRequired,
  /**
   * Allows Carousel to automatically move to next card after given interval.
   */
  autoplay: PropTypes.bool,
  /**
   * Specifies how much of the next card up is shown in pixels or percentage.
   */
  peekOffset: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  /**
   * Specifies the duration a Card will be shown before automatically switching to the next.
   */
  autoplayInterval: PropTypes.number,
  /**
   * Opacity of slides that are inactive.
   */
  inactiveOpacity: PropTypes.number,
  /**
   * Styling of the footer container.
   */
  paginationContainerStyle: PropTypes.object,
  /**
   * function that returns the component that will be used in place of default arrow right.
   */
  renderNextControl: PropTypes.func,
  /**
   * function that returns the component that will be used in place of default arrow left.
   */
  renderPreviousControl: PropTypes.func,
  /**
   * function that returns the component that will be used in place of default carousel bars.
   */
  renderPagination: PropTypes.func,
  /**
   * @ignore
   */
  dataLoc: PropTypes.string,
};

const defaultProps = {
  inverted: false,
  uniqueId: 'slide_carousel_bars_id',
  autoplay: false,
  viewport: 'desktop',
  autoplayIndicatorPosition: 'right',
  peekOffset: 0,
  inactiveOpacity: 0.5,
  autoplayInterval: 8000,
  paginationContainerStyle: {},
  renderNextControl: undefined,
  renderPreviousControl: undefined,
  renderPagination: undefined,
};

const ARROW_LARGE = '46px';
const ARROW_SMALL = '23px';

const CarouselContainer = styled.div`
  position: relative;
  overflow: hidden;
  width: 100%;
  user-select: none;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  box-sizing: border-box;
`;

const CarouselFooter = styled.div`
  width: 100%;
  position: absolute;
  bottom: 0;
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
`;

const CarouselSlot = styled.div`
  transition: opacity 0.3s ease;
  opacity: ${({ active, inactiveOpacity, count }) =>
    active || count === 1 ? 1 : inactiveOpacity};
  display: flex;
  order: ${({ order }) => order};
  width: ${({ peekOffset }) => `calc(100% - ${peekOffset})`};
  flex: 1 0 100%;
  flex-basis: 100%;
`;

const StaticSlot = styled.div`
  flex-grow: 1;
  display: flex;
`;

const ButtonWrapper = styled.button`
  margin-right: ${({ lastChild }) => (lastChild ? 0 : 10)}px;
  background-color: transparent;
  padding: 0px;
  border: none;
  cursor: pointer;
  outline: none;
`;

const ButtonGroup = styled.div`
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  position: absolute;
  top: 20px;
  right: 20px;
  z-index: 1;
`;

const IndicatorWrapper = styled.div`
  position: absolute;
  bottom: ${calculateRem(8)};
  right: ${({ autoplayIndicatorPosition }) =>
    autoplayIndicatorPosition === 'right' ? calculateRem(20) : undefined};
  left: ${({ autoplayIndicatorPosition }) =>
    autoplayIndicatorPosition === 'left' ? calculateRem(20) : undefined};
`;

// gets the correct clientX whether from touch or mouse event
const getClientX = e =>
  e.targetTouches ? e.targetTouches[0].clientX : e.clientX;

class CarouselWrapper extends React.PureComponent {
  constructor(props) {
    super(props);

    const { children } = props;

    this.slideWidth = 0;
    this.swipeStartPosition = 0;
    this.carouselRef = null;
    this.prevScrollPos = 0;
    this.fullRotation = 0;
    this.autoplayTimer = null;
    this.pauseTimer = null;
    this.slideCount = React.Children.count(children);
    this.childArray = React.Children.toArray(children);

    this.state = {
      position: 0,
      barPosition: 0,
      translation: 0,
      sliding: true,
      animate: false,
      swiping: false,
      swipeDirection: null,
      maxedViewport: false,
      delayedTranslation: false,
      inverted: this._getSlideInvertedProp(0, 0),
    };
  }

  componentDidMount() {
    this._startAutoplay();

    this.slideWidth = this.carouselRef.offsetWidth;

    this.fullRotation = -this.slideWidth;

    window.addEventListener('resize', this.resize);
    this.resize();

    const buttons = Array.prototype.slice.call(
      document.getElementsByTagName('button')
    );
    if (buttons.length > 2) {
      buttons.splice(0, 2);
      buttons.forEach(button => {
        button.setAttribute('tabindex', '-1');
      });
      buttons[1].setAttribute('tabindex', '0');
    }
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this.resize);
    clearInterval(this.autoplayTimer);
    clearTimeout(this.pauseTimer);
  }

  resize = () => {
    this.slideWidth = this.carouselRef.offsetWidth;

    const newTranslation = -this.slideWidth;
    this.setState({
      translation: newTranslation,
    });
  };

  _startAutoplay = () => {
    const { autoplayInterval, autoplay } = this.props;
    if (autoplayInterval && autoplay) {
      this.autoplayTimer = setInterval(() => {
        this._arrowToSlide(1, true)();
      }, Math.abs(autoplayInterval));
    }
  };

  _pauseAutoplay = () => {
    const { autoplayInterval, autoplay } = this.props;

    if (!autoplayInterval || !autoplay) return;

    clearInterval(this.autoplayTimer);
    clearTimeout(this.pauseTimer);
    this.pauseTimer = setTimeout(this._startAutoplay, 0);
  };

  _getSlideInvertedProp = (previousIndex, index) => {
    const { children, inverted } = this.props;

    const selectedChild =
      index === children.length - 1
        ? React.Children.toArray(children)[0]
        : React.Children.toArray(children)[index + 1];

    const buttons = Array.prototype.slice.call(
      document.getElementsByTagName('button')
    );

    if (buttons.length > 2) {
      buttons.splice(0, 2);
      const indexButton =
        index === children.length - 1 ? buttons[0] : buttons[index + 1];
      const previousButton =
        previousIndex === children.length - 1
          ? buttons[0]
          : buttons[previousIndex + 1];
      buttons.forEach(button => {
        if (button === indexButton) {
          button.setAttribute('tabindex', '0');
        }
        if (button === previousButton) {
          button.setAttribute('tabindex', '-1');
        }
      });
    }

    if ((selectedChild.props || {}).inverted !== undefined) {
      return selectedChild.props.inverted;
    }
    return inverted;
  };

  _getOrder = (index, position, children) => {
    const numItems = children.length || 1;
    if (index - position < 0) {
      return numItems - Math.abs(index - position);
    }

    return index - position;
  };

  _getActive = (index, position, children) => {
    const numItems = children.length - 1 || 1;
    if (index === 0) {
      return position === numItems;
    } else {
      if (index > this.slideCount - 1) {
        return false;
      }
      return index === position + 1;
    }
  };

  _getNextForwardIndex = index => {
    //index 2, direction forward
    if (index < this.slideCount - 1) {
      return (index += 1);
    } else if (index === this.slideCount - 1) {
      return 0;
    }
    return index;
  };

  _getNextBackwardIndex = index => {
    //index 0, direction forward
    if (index > 0) {
      return (index -= 1);
    } else if (index === 0) {
      return this.slideCount - 1;
    }
    return index;
  };

  _arrowToSlide = (direction, fromAutoplay) => {
    const { position, barPosition } = this.state;
    const { children } = this.props;

    if (!fromAutoplay) this._pauseAutoplay();
    if (position !== barPosition) {
      const nextIndex = this._getNextForwardIndex(barPosition);
      const previousIndex = this._getNextBackwardIndex(barPosition);
      this.setState({
        sliding: true,
        position: direction === 'forward' ? nextIndex : previousIndex,
        barPosition: direction === 'forward' ? nextIndex : previousIndex,
        translation: direction === 'forward' ? '0' : 2 * -this.slideWidth,
        inverted: this._getSlideInvertedProp(
          position,
          direction === 'forward' ? nextIndex : previousIndex
        ),
      });
    } else {
      const nextIndex = this._getNextForwardIndex(position);
      const previousIndex = this._getNextBackwardIndex(position);
      this.setState({
        sliding: true,
        position: direction === 'forward' ? nextIndex : previousIndex,
        barPosition: direction === 'forward' ? nextIndex : previousIndex,
        translation: direction === 'forward' ? '0' : 2 * -this.slideWidth,
        inverted: this._getSlideInvertedProp(
          position,
          direction === 'forward' ? nextIndex : previousIndex
        ),
      });
    }

    setTimeout(() => {
      this.setState({
        sliding: false,
        translation: -this.slideWidth,
      });
    }, 20);
    this._resetIndicator && this._resetIndicator();
  };

  _swipeToSlide = (original, translation) => {
    const { position } = this.state;
    const nextIndex = this._getNextForwardIndex(position);
    const previousIndex = this._getNextBackwardIndex(position);
    if (!(Math.abs(original) <= 0.1 * this.slideWidth)) {
      if (original >= 0) {
        this.setState({
          sliding: true,
          position: nextIndex,
          barPosition: nextIndex,
          translation: -original,
          inverted: this._getSlideInvertedProp(position, nextIndex),
        });
      } else {
        this.setState({
          sliding: true,
          position: previousIndex,
          barPosition: previousIndex,
          translation: -this.slideWidth - translation,
          inverted: this._getSlideInvertedProp(position, previousIndex),
        });
      }
    }

    setTimeout(() => {
      this.setState({
        sliding: false,
        translation: -this.slideWidth,
      });
    }, 20);
  };

  _moveToSlide = carouselBarIndex => {
    const { position, barPosition } = this.state;
    const newIndex = carouselBarIndex - 1;
    //moving to first position
    if (position !== 1 && newIndex === 1) {
      if (position === 0) {
        this._arrowToSlide('forward', false)();
        return;
      } else {
        this.setState({
          position: 1,
          barPosition: newIndex,
          sliding: true,
          translation: -this.slideWidth * position,
          inverted: this._getSlideInvertedProp(barPosition, newIndex),
        });
        setTimeout(() => {
          this.setState({
            sliding: false,
            translation: -this.slideWidth,
          });
        }, 20);
      }
      //moving to other positions
    } else {
      this.setState({
        position: 1,
        barPosition: newIndex,
        sliding: false,
        translation: -this.slideWidth * newIndex,
        inverted: this._getSlideInvertedProp(barPosition, newIndex),
      });
    }
  };

  _snapToCard = swipeDistance => {
    return swipeDistance <= 0
      ? -Math.ceil(-this.slideWidth - swipeDistance)
      : -Math.floor(this.slideWidth - swipeDistance);
  };

  _handleCarouselSwipeStart = e => {
    const { maxedViewport, barPosition } = this.state;
    const { children } = this.props;
    if (maxedViewport) return;

    const clientX = getClientX(e);
    this.prevScrollPos = clientX;
    this.swipeStartPosition = clientX;
    this._pauseAutoplay();
    this.setState({
      swiping: true,
      sliding: true,
      position: barPosition,
      translation: -this.slideWidth,
    });
  };

  _handleCarouselSwipeMove = e => {
    const { maxedViewport, swiping, translation } = this.state;
    if (!swiping || maxedViewport) return;

    const clientX = getClientX(e);
    const deltaFromPrevScroll = clientX - this.prevScrollPos;
    const newTranslation = translation + deltaFromPrevScroll;
    this.prevScrollPos = clientX;
    this._pauseAutoplay();
    this.setState({ translation: newTranslation });
  };

  _handleCarouselSwipeEnd = () => {
    const { maxedViewport, swiping, translation } = this.state;

    if (!swiping || maxedViewport) return;
    const swipeDistance = this.swipeStartPosition - this.prevScrollPos;
    const snap = this._snapToCard(swipeDistance);
    this.setState({ swiping: false });
    this._swipeToSlide(swipeDistance, snap);
    this._resetIndicator && this._resetIndicator();
  };

  _renderChildren = children => {
    const { inverted, inactiveOpacity, peekOffset } = this.props;
    const { position, barPosition } = this.state;
    let childArr = React.Children.toArray(children);
    const newChildren = [...childArr];
    if (children.length === 2) {
      newChildren.push(newChildren[position]);
      newChildren.push(newChildren[position === 0 ? 1 : 0]);
    }
    if (barPosition === this.slideCount - 1) {
      newChildren.push(newChildren[1]);
    }

    return newChildren.map((child, index) => (
      <CarouselSlot
        index={index}
        peekOffset={peekOffset}
        order={this._getOrder(index, position, children)}
        key={index}
        active={this._getActive(index, barPosition, children)}
        inverted={inverted}
        count={this.slideCount}
        inactiveOpacity={inactiveOpacity}
      >
        {child}
      </CarouselSlot>
    ));
  };

  _renderChildrenInOrder = children => {
    const { showDividers, inverted } = this.props;
    const { position } = this.state;

    return this.childArray.map((child, index) => (
      <StaticSlot key={index} border={showDividers} inverted={inverted}>
        {this.childArray[(position + index) % this.slideCount]}
      </StaticSlot>
    ));
  };

  _renderCarouselChildren = children => {
    if (children && this.slideCount === 1) {
      return children;
    } else if (children) {
      return this._renderChildrenInOrder(children);
    }
  };

  _setIndicatorRef = ref => {
    let noop = () => {};
    if (!ref || ref === null || !ref._resetIndicator)
      return (this._resetIndicator = noop);
    this._resetIndicator = ref._resetIndicator;
  };

  render() {
    const {
      children,
      viewport,
      uniqueId,
      minSlideWidth,
      peekOffset,
      autoplay,
      autoplayIndicatorPosition,
      autoplayInterval,
      paginationContainerStyle,
      renderNextControl,
      renderPreviousControl,
      renderPagination,
      dataLoc,
    } = this.props;

    const {
      inverted,
      position,
      barPosition,
      translation,
      sliding,
      animate,
    } = this.state;

    const arrowSize = viewport === 'mobile' ? ARROW_SMALL : ARROW_LARGE,
      arrowStyle = {
        height: arrowSize,
        width: arrowSize,
        minHeight: arrowSize,
        minWidth: arrowSize,
      },
      arrowColor = inverted ? colors.white : colors.black;

    const viewTranslation = this.slideCount !== 1 ? translation : 0;

    if (!sliding) {
      setTimeout(() => {
        this.setState({
          sliding: true,
        });
      }, 20);
    }

    return (
      <CarouselContainer
        inverted={inverted}
        slideCount={this.slideCount}
        id={uniqueId}
        peekOffset={parseInt(peekOffset)}
      >
        <ButtonGroup>
          <ButtonWrapper
            data-loc={dataLoc}
            tabIndex={0}
            onClick={() => {
              this._arrowToSlide('backward', false);
            }}
          >
            {renderPreviousControl ? (
              renderPreviousControl({ inverted })
            ) : (
              <Icon
                name="arrow-left"
                color={arrowColor}
                style={arrowStyle}
                tabIndex={-1}
              />
            )}
          </ButtonWrapper>
          <ButtonWrapper
            data-loc={dataLoc}
            lastChild
            onClick={() => {
              this._arrowToSlide('forward', false);
            }}
            tabIndex={0}
          >
            {renderNextControl ? (
              renderNextControl({ inverted })
            ) : (
              <Icon
                name="arrow-right"
                color={arrowColor}
                style={arrowStyle}
                tabIndex={-1}
              />
            )}
          </ButtonWrapper>
        </ButtonGroup>
        <div
          // style here because translation changes frequently, styled-components are too slow
          style={{
            display: 'flex',
            height: '100%',
            width: `calc(100% - ${peekOffset})`,
            transform: `translateX(${viewTranslation}px)`,
            transition: `transform ${!sliding ? 0.3 : 0}s ease`,
          }}
          onMouseDown={this._handleCarouselSwipeStart}
          onMouseMove={this._handleCarouselSwipeMove}
          onMouseLeave={this._handleCarouselSwipeEnd}
          onMouseUp={this._handleCarouselSwipeEnd}
          onTouchStart={this._handleCarouselSwipeStart}
          onTouchMove={this._handleCarouselSwipeMove}
          onTouchEnd={this._handleCarouselSwipeEnd}
          ref={el => {
            this.carouselRef = el;
          }}
        >
          {!!children && this._renderChildren(children)}
        </div>

        <CarouselFooter style={paginationContainerStyle}>
          {renderPagination ? (
            renderPagination({
              goToSlide: this._moveToSlide,
              slideCount: this.slideCount,
              activeSlide: barPosition + 1,
              inverted,
            })
          ) : (
            <CarouselBars
              uniqueId={uniqueId}
              goToSlide={this._moveToSlide}
              slideCount={this.slideCount}
              activeSlide={barPosition + 1}
              inverted={inverted}
              ariaLabel="Slide Carousel"
            />
          )}
        </CarouselFooter>
        {autoplayIndicatorPosition !== 'hidden' &&
          autoplayInterval &&
          autoplay && (
            <IndicatorWrapper
              autoplayIndicatorPosition={autoplayIndicatorPosition}
            >
              <ProgressIndicator
                ref={this._setIndicatorRef}
                interval={autoplayInterval}
                inverted={inverted}
              />
            </IndicatorWrapper>
          )}
      </CarouselContainer>
    );
  }
}

CarouselWrapper.propTypes = propTypes;
CarouselWrapper.defaultProps = defaultProps;

export default withVDSManager(CarouselWrapper);
