import React from 'react';
import ReactDOM, { findDOMNode } from 'react-dom';
import styled from 'styled-components';
import { calculateRem } from '@uie/javascript-style-helpers';
import PropTypes from 'prop-types';
import { colors, calculateSpacing } from '@vds-core/theme';
import { withVDSManager } from '@vds-core/utilities';

const propTypes = {
  /**
   * @deprecated
   * The current active slide/bar of the carousel.
   */
  currentSlide: PropTypes.number,
  /**
   * The current active slide/bar of the carousel.
   */
  activeSlide: PropTypes.number.isRequired,
  /**
   * @ignore
   */
  selectedSlide: PropTypes.number,
  /**
   * Allows a unique ID to be passed to the component.
   */
  id: PropTypes.string,
  /**
   *	Unique identifier value for 'aria-controls'.
   */
  uniqueId: PropTypes.string.isRequired,
  /**
   * If provided, used as string that labels the element for accessibility.
   */
  ariaLabel: PropTypes.string,
  /**
   * @deprecated
   * If 'true', CarouselBars will be white for contrast on a dark background.
   */
  isSlideDark: PropTypes.bool,
  /**
   * If 'true', CarouselBars will be white for contrast on a dark background.
   */
  inverted: PropTypes.bool,
  /**
   * Total number of slides to render total 'Bars'.
   */
  slideCount: PropTypes.number.isRequired,
  /**
   * Function called when a bar is clicked.
   */
  goToSlide: PropTypes.func.isRequired,
  /**
   * @ignore
   */
  focusState: PropTypes.bool,
  /**
   * @ignore
   */
  colorConfig: PropTypes.object,
  /**
   * Allows a string to be provided for analytics.
   */
  'data-analyticstrack': PropTypes.string,
  /**
   * Allows a string to be provided for analytics.
   */
  'data-track': PropTypes.string,
  /**
   * Allows a string to be provided for click stream.
   */
  'data-clickstream': PropTypes.string,
  /**
   * Function that returns an aria label for each carousel bar
   */
  slideAriaLabel: PropTypes.func,
};

const defaultProps = {
  isSlideDark: false,
  inverted: false,
  focusState: null,
  colorConfig: colors,
};

const StyledSwiperList = styled.ol`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding-left: 0;
`;

const StyledSwiperDot = styled.li`
  position: relative;
  display: block;
  width: ${calculateRem(24)};
  margin-right: ${calculateSpacing('1X')};
  cursor: pointer;
  height: ${calculateRem(4)};
  outline-offset: 2px;
  outline-color: white;
  outline: none;

  &:active,
  &:hover {
    outline: none;
  }

  ${({ focusState }) =>
    !focusState &&
    ` 
  &:focus{
    outline: -webkit-focus-ring-color auto 5px;
    outline: Highlight auto 5px;

  }

  `};

  &::after {
    content: '';
    position: absolute;
    height: ${calculateRem(1)};
    bottom: 0%;
    left: 0;
    right: 0;
    background-color: ${({ colors }) => colors.coolGray6};
    transition: height 250ms, background-color 250ms;
  }

  &:last-child {
    margin-right: 0;
  }

  &:hover {
    &::after {
      height: ${calculateRem(4)};
      transition: height 250ms, background-color 250ms;
    }
  }

  ${({ active, colors }) =>
    active &&
    `
      &::after {
          height: ${calculateRem(4)};
          background-color: ${colors.black};
          transition: height 250ms, background-color 250ms;
      }
  `};

  ${({ active, inverted, isSlideDark, colors }) =>
    !active &&
    (isSlideDark || inverted) &&
    `
      &:focus{
        outline-color: white;
      }
      &::after {
          background-color: ${colors.coolGray3};
          transition: height 250ms, background-color 250ms;
      }
  `};

  ${({ active, isSlideDark, inverted, colors }) =>
    active &&
    (isSlideDark || inverted) &&
    `
      &:focus{
        outline-color: white;
      }
      &::after {
          height: ${calculateRem(4)};
          background-color: ${colors.white};
          transition: height 250ms, background-color 250ms;
      }
  `};

  ${({ focusState }) =>
    focusState &&
    `
    &:focus:not(:hover) {
      outline-style: dashed;
      outline-width: 1px;
    }
    &:focus:not(:focus-visible){
      outline-style: none;
      outline-width: none;
    }
    &:focus-visible{
      outline-style: none;
      outline-width: none;      
    }
  `};
`;

class CarouselBars extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      focusedBar: 0,
    };

    this.barRefs = [];
  }

  _setSlotRef = (element, index) => {
    if (!element) return;

    this.barRefs[index] = element;
  };

  _blurElements = e => {
    [e.target, document.activeElement].forEach(element => {
      // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
      try {
        // Support: IE9+
        // If the <body> is blurred, IE will switch windows
        element && element.nodeName.toLowerCase() !== 'body' && element.blur();
      } catch (error) {}
    });
  };

  _goSlide = (e, index) => {
    const { goToSlide } = this.props;
    e.preventDefault();
    if (e.type === 'click') {
      this._blurElements(e);
    }
    goToSlide(index, false);
  };

  _onMouseDown = e => {
    e.preventDefault();
    this._blurElements(e);
  };

  _onKeyDown = e => {
    const { focusedBar } = this.state;
    const { activeSlide, goToSlide } = this.props;

    if (e.keyCode === 39) {
      if (focusedBar + 1 === this.barRefs.length) {
        goToSlide(0, false);
        this.setState({ focusedBar: 0 });
        return findDOMNode(this.barRefs[0]).focus();
      } else {
        goToSlide(focusedBar + 1, false);
        this.setState({ focusedBar: focusedBar + 1 });
        return findDOMNode(this.barRefs[focusedBar + 1]).focus();
      }
    } else if (e.keyCode === 37) {
      if (focusedBar - 1 < 0) {
        goToSlide(this.barRefs.length - 1);
        this.setState({ focusedBar: this.barRefs.length - 1 });
        return findDOMNode(this.barRefs[this.barRefs.length - 1]).focus();
      } else {
        goToSlide(focusedBar - 1, false);
        this.setState({ focusedBar: focusedBar - 1 });
        return findDOMNode(this.barRefs[focusedBar - 1]).focus();
      }
    }
  };

  render() {
    const {
      slideCount,
      currentSlide,
      selectedSlide: selectedSlideProp,
      activeSlide,
      isSlideDark,
      inverted,
      id,
      uniqueId,
      goToSlide,
      ariaLabel,
      colorConfig,
      focusState,
      'data-analyticstrack': analyticsTrack,
      'data-track': track,
      'data-clickstream': clickStream,
      slideAriaLabel,
    } = this.props;

    var selectedSlide = activeSlide || selectedSlideProp;

    // this is a tabbed carousel so we do not need a aria-roledescription
    return (
      <StyledSwiperList
        {...this.props}
        aria-label={ariaLabel}
        aria-controls={uniqueId}
        role={`tablist`}
      >
        {Array.from({ length: slideCount }).map((element, index) => {
          let defaultAriaLabel = `Go to slide ${index + 1} of ${slideCount} ${
            (selectedSlide || currentSlide) === index + 1 ? '' : ' unselected'
          }`;
          return (
            <StyledSwiperDot
              data-clickstream={clickStream}
              data-track={track}
              data-analyticstrack={analyticsTrack}
              focusState={focusState}
              colors={colorConfig}
              onMouseDown={this._onMouseDown}
              key={index}
              active={activeSlide === index}
              data-index={index}
              aria-selected={activeSlide === index ? true : null}
              onKeyDown={this._onKeyDown}
              isSlideDark={inverted || isSlideDark}
              onClick={e => this._goSlide(e, index)}
              aria-label={
                slideAriaLabel
                  ? slideAriaLabel(defaultAriaLabel, index)
                  : defaultAriaLabel
              }
              tabIndex={activeSlide === index ? 0 : -1}
              role={`tab`}
              ref={el => this._setSlotRef(el, index)}
            />
          );
        })}
      </StyledSwiperList>
    );
  }
}

CarouselBars.propTypes = propTypes;
CarouselBars.defaultProps = defaultProps;

export default withVDSManager(CarouselBars);
