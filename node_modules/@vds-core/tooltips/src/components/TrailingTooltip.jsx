import React, { Fragment } from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import Tooltip from './Tooltip';
import { colors } from '@vds/theme';
import { calculateRem } from '@uie/javascript-style-helpers';

const propTypes = {
  /**
   * Content that will be passed to the typography.
   */
  children: PropTypes.string,
  /**
   * Primitive used for the typgraphy.
   */
  typographyType: PropTypes.oneOf(['title', 'subtitle', 'body', 'micro']),
  /**
   * Primitive used for the typgraphy.
   */
  typographyPrimitive: PropTypes.oneOf([
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'span',
    'p',
  ]),
  /**
   * Viewport the font styling is based on. Desktop and tablet are the same size.
   */
  viewport: PropTypes.oneOf(['desktop', 'tablet', 'mobile']),
  /**
   * Size of the typography component to be rendered.
   */
  typographySize: PropTypes.string,
  /**
   * Color of the typography component to be rendered.
   */
  typographyColor: PropTypes.string,
  /**
   * Adds a fontWeight of bold to the typography component, only valid for Body and Title typographyTypes.
   */
  bold: PropTypes.bool,
  /**
   * Determines the size of the tooltip
   */
  tooltipSize: PropTypes.oneOf(['small', 'large']),
  /**
   * Determines the content of the tooltip
   */
  tooltipContent: PropTypes.any,
  /**
   * Determines the title of the tooltip
   */
  tooltipTitle: PropTypes.string,
  /**
   * @ignore Passes in VDS Body component
   */
  Body: PropTypes.func,
  /**
   * @ignore Passes in VDS Body component
   */
  Micro: PropTypes.func,
  /**
   * @ignore Passes in VDS Body component
   */
  Title: PropTypes.func,
  /**
   * @ignore Passes in VDS Body component
   */
  Subtitle: PropTypes.func,
  /**
   * @ignore Passes in VDS Body font configuration
   */
  bodyConfig: PropTypes.object,
  /**
   * @ignore Passes in VDS color configuration
   */
  colorConfig: PropTypes.object,
  /**
   * @ignore Passes in VDS icon configuration
   */
  iconConfig: PropTypes.object,
};

const defaultProps = {
  typographyType: 'body',
  viewport: 'desktop',
  typographySize: 'small',
  tooltipSize: 'small',
};

const ChildWrapper = styled.span`
  display: inline-flex;
  align-items: center;
`;

const TooltipContent = styled.span`
  font-weight: 400;
`;

const StyledSpan = styled.span`
  display: inline-block;
  outline: none;
`;

const InlineWrapper = styled.span`
  display: inline-flex;
  vertical-align: middle;
  position: relative;
  top: ${({ type }) => (type === 'body' || type === 'micro' ? 0 : 1)}px;
`;

function _formatChildren(childArray) {
  let textWithoutIcon = '';
  childArray.map((item, index) => {
    if (index !== childArray.length - 1) {
      textWithoutIcon += item + ' ';
    }
  });
  return textWithoutIcon;
}

function checkForNode(children) {
  let lastIndex = children.length - 1, //number of last index in child array
    lastChild = children[lastIndex], //last child in child array
    isNode = typeof children[lastIndex] !== 'string', //if last child is node
    isString = typeof children === 'string', //if children are a string
    firstNodes = [];

  if (children.length === undefined || children.length <= 1)
    return { childArray: [], textWithIcon: children }; //if only one child put with caret and return

  if (isNode || !isString) {
    //if the last child is node or mixture put last with the caret
    children.map((child, index) => {
      //add all children to first nodes except the last one
      if (index !== lastIndex) firstNodes[index] = child;
    });
    return { childArray: firstNodes, textWithIcon: lastChild };
  }
  //if all children are "strings", put last word with caret
  let childArray = children.split(' ');
  let textWithIcon = childArray[childArray.length - 1];
  return {
    childArray: _formatChildren(childArray),
    textWithIcon: textWithIcon,
  };
}

function _renderWithIcon(props) {
  const {
    children,
    tooltipSize,
    tooltipTitle,
    tooltipContent,
    typographySize,
    typographyType,
    colorConfig,
    bodyConfig,
    iconConfig,
  } = props;
  let childArray = children ? checkForNode(children).childArray : [];
  let textWithIcon = children ? checkForNode(children).textWithIcon : '';
  return (
    <Fragment>
      <StyledSpan tabIndex={-1}>
        {childArray}
        <ChildWrapper>
          {textWithIcon}
          <InlineWrapper type={typographyType} size={typographySize}>
            <Tooltip
              focusState
              hoverState
              activeState
              iconConfig={iconConfig}
              bodyConfig={bodyConfig}
              colorConfig={colorConfig}
              typescale="VDS"
              dialogPadding={calculateRem(12, 0, 12, 12)}
              size={tooltipSize}
              title={tooltipTitle}
            >
              <TooltipContent>{tooltipContent}</TooltipContent>
            </Tooltip>
          </InlineWrapper>
        </ChildWrapper>
      </StyledSpan>
    </Fragment>
  );
}

function _calcTypographyComponent(props) {
  const { Body, Subtitle, Micro, Title, typographyType } = props;
  let comp = Body;
  if (typographyType === 'title') comp = Title;
  if (typographyType === 'subtitle') comp = Subtitle;
  if (typographyType === 'micro') comp = Micro;

  return comp;
}

const TrailingTooltip = props => {
  const {
    typographyPrimitive,
    viewport,
    typographySize,
    colorConfig,
    bold,
    typographyColor,
  } = props;

  const TypographyComponent = _calcTypographyComponent(props);
  return (
    <TypographyComponent
      primitive={typographyPrimitive}
      viewport={viewport}
      size={typographySize}
      color={typographyColor}
      bold={bold}
      tabIndex={-1}
    >
      {_renderWithIcon(props)}
    </TypographyComponent>
  );
};

TrailingTooltip.defaultProps = defaultProps;
TrailingTooltip.propTypes = propTypes;

export default TrailingTooltip;
