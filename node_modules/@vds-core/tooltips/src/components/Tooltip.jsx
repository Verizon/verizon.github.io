import React, { Component, Fragment } from 'react';
import PropTypes from 'prop-types';
import UNSAFE_SetEnvRef from '@uie/set-env-ref';
import styled, { css } from 'styled-components';
import cuid from 'cuid';
import { calculateRem } from '@uie/javascript-style-helpers';
import AnchorIconBase from './AnchorIconBase';
import TooltipDialog from './TooltipDialog';
import AnchorIcon from '../utils/AnchorIcon';
import { IconData } from '@vds-core/icons';
import { BodyConfig, TypographyConfig } from '@vds-core/typography';
import { colors } from '@vds-core/theme';
import { withVDSManager } from '@vds-core/utilities';

const propTypes = {
  /**
   * @deprecated
   * Function that returns an HTML element or React component to be used as a custom anchor for the tooltip. The function is called with a React ref, and an object that will pass back aria-describedby and aria-expanded that has to be passed to the returned anchor element/component.
   */
  anchorElement: PropTypes.func,
  /**
   * String, React Component, or HTML to rendered as the body of the tooltip.
   */
  children: PropTypes.any,
  /**
   * @deprecated
   * String, React Component, or HTML to rendered as the header of the tooltip.
   */
  header: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
  /**
   * @deprecated
   * Boolean used to choose secondary version of icon element. <strong>Can only be used with <code>base icon element
   */
  secondary: PropTypes.bool,
  /**
   * Boolean used to invert icon element color.<strong>Can only be used with <code>base icon element</code></strong>
   */
  inverted: PropTypes.bool,
  /**
   * Size of icon
   */
  size: PropTypes.string,
  /**
   * Number used as a pixel value to offset space between tooltip and <code>anchorElement</code>. <strong>Can only be used with <code>anchorElement</code></strong>
   */
  offset: PropTypes.number,
  /**
   * String used to choose secondary or primary version of icon element. <strong>Can only be used with <code>base icon element</code></strong>
   */
  type: PropTypes.string,
  /**
   * String, React Component, or HTML to rendered as the header of the tooltip.
   */
  title: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
  /**
   * A String label that is required for accessibility, the should be very terse description ot the tooltips content.
   */
  ariaLabel: PropTypes.string,
  /**
   * Function that returns an HTML element or React component to be used as a custom anchor for the tooltip. The function is called with a React ref, and an object that will pass back aria-describedby, aria-expanded, and aria-label that has to be passed to the returned anchor element/component.
   */
  renderAnchorElement: PropTypes.func,
  /**
   *@ignore
   *Icon package used to render info icon as anchor
   */
  iconConfig: PropTypes.object,
  /**
   *@ignore
   *Enables focus state with dashed lines
   */
  focusState: PropTypes.bool,
  //todo:
  /**
   *@ignore
   *Enables hover state with medium weight icon
   */
  hoverState: PropTypes.bool,
  /**
   *@ignore
   *Enables grey medium weight icon on active
   */
  activeState: PropTypes.bool,
  /**
   *@ignore
   *configuration for body component
   */
  bodyConfig: PropTypes.object,
  /**
   *@ignore
   *configuration for body component
   */
  colorConfig: PropTypes.object,
  /**
   *
   *@ignore// typescale for body config
   */
  typescale: PropTypes.string,
  /**
   *
   *@ignore// padding for inside of dialog
   */
  dialogPadding: PropTypes.string,
  /**
   * Allows a unique ID to be passed to the component.
   */
  id: PropTypes.string,
  /**
   * Boolean that activates disabled state
   */
  disabled: PropTypes.bool,
  /**
   * Allows a unique component ID to be passed to the component as a reference for positioning other than the window object.
   */
  containerId: PropTypes.string,
};

const defaultProps = {
  anchorElement: null,
  header: null,
  secondary: false,
  inverted: false,
  size: 'large',
  offset: 0,

  //added after renaming
  type: null,
  title: null,
  ariaLabel: 'More information',
  renderAnchorElement: null,
  iconConfig: IconData,
  focusState: false,
  hoverState: false,
  activeState: false,
  bodyConfig: BodyConfig,
  typescale: TypographyConfig.getTypescale(),
  dialogPadding: calculateRem(12, 0, 16, 12),
  colorConfig: colors,
  disabled: false,
};

const ARIA_LIVE_VALUE = 'polite';

const TooltipWrapper = styled.span`
  display: inline-flex;
  align-items: center;
  position: relative;
  padding: 0;
  outline: none;
  ${({ disabled }) =>
    disabled &&
    `
    pointer-events: none;
    cursor: default;
  `};
`;

const TooltipIconWrapper = styled.span`
  display: flex;
  flex-direction: column;
  outline: none;
  z-index: ${({ clicked, showDialog, hovered }) =>
    clicked || hovered || showDialog ? 2 : 0};
`;

const CustomAnchorElementWrapper = styled.span`
  display: inline-block;
  position: relative;
`;

const IconPositionWrapper = styled.span`
  position: absolute;
  outline: none;
`;

const HitArea = styled.span`
  transform: translate(-50%, -50%);
  text-align: center;
  cursor: pointer;
  position: absolute;
  top: 50%;
  left: 50%;
  bottom: 50%;
  height: ${calculateRem(44)};
  width: ${calculateRem(44)};
  z-index: 1;
  outline: none;
`;

const HoverZone = styled.span`
  transform: translate(-50%, -50%);
  text-align: center;
  cursor: pointer;
  position: absolute;
  top: 50%;
  left: 50%;
  bottom: 50%;
  height: ${calculateRem(44)};
  width: ${calculateRem(228)};
  z-index: 1;
`;

function _isiOS() {
  let isIPAD =
    navigator.platform === 'MacIntel' &&
    navigator.maxTouchPoints > 1 &&
    !window.MSStream;
  let isMobileDevice = /iPhone|iPad/i.test(navigator.userAgent);
  return isMobileDevice || isIPAD;
}

function _checkIfIe() {
  var ua = window.navigator.userAgent;

  var msie = ua.indexOf('MSIE ');
  if (msie > 0) {
    // IE 10 or older => return version number
    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
  }

  var trident = ua.indexOf('Trident/');
  if (trident > 0) {
    // IE 11 => return version number
    var rv = ua.indexOf('rv:');
    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
  }

  var edge = ua.indexOf('Edge/');
  if (edge > 0) {
    // Edge => return version number
    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
  }

  // other browser
  return false;
}

class Tooltip extends Component {
  state = {
    hovered: false,
    keyboardFocused: false,
    showDialog: false,
    clicked: false,
    hoveredWhenFocused: false,
    active: false,
    customAnchorPresent: false,
    isIe: _checkIfIe(),
    isiOS: _isiOS(),
    scrollPosition: null,
    expanded: false,
    tooltipAnchorCoordinates: {},
  };

  componentDidMount = () => {
    document.addEventListener('click', this.handleClickOutside);
    window.addEventListener(
      'scroll',
      this.setAnchorElementPositionProperties()
    );
    window.addEventListener(
      'resize',
      this.setAnchorElementPositionProperties()
    );

    // this check is to see if a custom element is being used as an anchor
    // this flag will activate different styles for the dialog based on the boolean
    if (this.props.anchorElement || this.props.renderAnchorElement) {
      this.setState({ customAnchorPresent: true });
    }
  };

  componentDidUpdate = (prevProps, prevState) => {
    if (prevState.showDialog !== this.state.showDialog) {
      document.getElementById(this.tooltipId).focus();
    }
  };

  componentWillUnmount = () => {
    document.removeEventListener('click', this.handleClickOutside);
    window.removeEventListener(
      'scroll',
      this.setAnchorElementPositionProperties()
    );
    window.removeEventListener(
      'resize',
      this.setAnchorElementPositionProperties()
    );
  };

  setAnchorElementPositionProperties = () => {
    // get the reference to the current tooltipAnchor
    const tooltipAnchor = this.toolTipAnchorRef;
    const tooltipAnchorRef = tooltipAnchor;
    const tooltipAnchorCoordinates = tooltipAnchorRef.getBoundingClientRect();
    // assign tooltipAnchorCoordinates the value of the current anchor ref boundingClientRect
    this.setState({ tooltipAnchorCoordinates });
  };

  //Open the tooltip
  setDialogState = () => this.setState({ showDialog: true });

  //Lower z-index when clicked
  setClickedState = () =>
    this.setState(prevState => ({ clicked: !prevState.clicked }));

  //Hide the tooltip
  deactivateDialogState = () => this.setState({ showDialog: false });

  //Remove focuse from keyboard press
  deactivateClickedState = () =>
    this.setState({ keyboardFocused: false, forceClose: false });

  handleKeyboardInput = (e, focused) => {
    const { showDialog } = this.state;
    if (e.keyCode === 32) e.preventDefault();
    //For the new passthrough icon focus
    if (
      this.props.focusState &&
      focused &&
      !this.state.keyboardFocused &&
      !this.state.clicked &&
      !this.state.showDialog
    ) {
      this.setState({ keyboardFocused: !this.state.keyboardFocused });
    } else if (
      this.props.focusState &&
      !focused &&
      this.state.keyboardFocused
    ) {
      this.setState({ keyboardFocused: !this.state.keyboardFocused });
    }

    if (
      e.keyCode === 13 ||
      e.keyCode === 32 || // return key
      (e.keyCode === 27 && showDialog) // esc key
    ) {
      this.setState({
        // toggle showDialog state based on keyboard interaction
        showDialog: !this.state.showDialog,
        keyboardFocused: !this.state.keyboardFocused,
        expanded: !this.state.expanded,
      });
    } else if (e.shiftKey && e.keyCode === 9) {
      this.deactivateDialogState(); // deactivate dialog if user shift tabs
    } else if (e.keyCode === 9 && this.showDialog) {
      this.deactivateDialogState(); // deactivate dialog if use tabs away
    } else if (e.keyCode === 9) {
      this.setState({
        keyboardFocused: !this.state.keyboardFocused,
      });
    }

    if (
      this.anchorWithRef !== null &&
      this.anchorElementProps.props.onKeyDown
    ) {
      this.anchorElementProps.props.onKeyDown(e);
    }

    if (this.anchorWithRef !== null && this.anchorElementProps.props.onBlur) {
      this.anchorElementProps.props.onBlur(e);
    }
  };

  handleClickOutside = e => {
    // check if current event contains ref if not close dialog
    let toolTipAnchorRef = this.toolTipAnchorRef;
    if (toolTipAnchorRef && !toolTipAnchorRef.contains(e.target)) {
      this.deactivateDialogState();
      this.deactivateClickedState();
      this.setState({ scrollPosition: 0 });
      if (this.state.clicked) {
        this.setClickedState();
      }
    }
  };

  handleMouseEnter = e => {
    if (this.state.keyboardFocused) {
      this.setState({ hoveredWhenFocused: true, keyboardFocused: false });
    }

    if (this.state.showDialog && this.state.clicked) {
      this.setState({ hovered: true });
      return;
    }

    this.openTooltipTimeout = setTimeout(() => {
      this.setState({ showDialog: true, hovered: true });
    }, 200);

    if (
      this.anchorWithRef !== null &&
      this.anchorElementProps.props.onMouseEnter
    ) {
      this.anchorElementProps.props.onMouseEnter(e);
    }
  };

  handleMouseExit = e => {
    if (this.state.clicked && this.state.showDialog) {
      return;
    }
    // clear time out to prevent showDialog being set to true unintentionally
    clearTimeout(this.openTooltipTimeout);

    this.setState({ hovered: false, showDialog: false, forceClose: false });

    if (
      this.anchorWithRef !== null &&
      this.anchorElementProps.props.onMouseLeave
    ) {
      this.anchorElementProps.props.onMouseLeave(e);
    }

    if (this.state.hoveredWhenFocused) {
      this.setState({ hoveredWhenFocused: false, keyboardFocused: true });
    }
  };

  handleMouseDown = e => {
    this.setState({ active: true });
    if (this.state.clicked) {
      this.setState({ forceClose: true });
    }
    this.deactivateDialogState();
    this.setDialogState();
    this.setClickedState();

    if (
      this.anchorWithRef !== null &&
      this.anchorElementProps.props.onMouseDown
    ) {
      this.anchorElementProps.props.onMouseDown(e);
    }
  };

  handleMouseUp = e => {
    this.setState({ active: false });
    if (this.state.forceClose) {
      this.deactivateDialogState();
      this.deactivateClickedState();
      e.currentTarget.blur();
    }

    if (
      this.anchorWithRef !== null &&
      this.anchorElementProps.props.onMouseUp
    ) {
      this.anchorElementProps.props.onMouseUp(e);
    }
  };

  _onFocus = e => {
    this.handleKeyboardInput(e, true);
  };

  setAnchorElement = () => {
    const computedProps = {
      ariaDescribedBy: this.ariaId,
      ariaExpanded: this.state.showDialog,
      ariaLabel: this.state.ariaLabel,
      ariaLive: ARIA_LIVE_VALUE,
      ...{ [this.refKey]: elem => (this.toolTipAnchorRef = elem) },
    };

    if (this.props.anchorElement) {
      return this.props.anchorElement(computedProps);
    } else if (this.props.renderAnchorElement) {
      return this.props.renderAnchorElement(computedProps);
    }
    return null;
  };

  _setScrollPosition = y => {
    this.setState({ scrollPosition: y });
  };

  refKey = UNSAFE_SetEnvRef();

  ariaId = `tooltip-${cuid()}`;

  tooltipId = cuid();
  // callback to render prop with tooltipAnchorRef
  anchorWithRef = this.setAnchorElement();
  // use to reference to the anchorWithRef so that in the event we were passed any props
  // we can invoke those props
  anchorElementProps = this.anchorWithRef;

  renderTooltipDialog = () => {
    if (this.state.showDialog && !this.props.disabled) {
      return (
        <TooltipDialog
          scrollPosition={this.state.scrollPosition}
          setScrollPosition={this._setScrollPosition}
          colorConfig={this.props.colorConfig}
          bodyConfig={this.props.bodyConfig}
          typescale={this.props.typescale}
          dialogPadding={this.props.dialogPadding}
          clicked={this.state.clicked}
          customAnchorElement={this.toolTipAnchorRef}
          customAnchorPresent={this.state.customAnchorPresent}
          content={this.props.children}
          deactivateDialogState={this.deactivateDialogState}
          header={this.props.header}
          title={this.props.title}
          ariaId={this.ariaId}
          keyboardFocused={this.state.keyboardFocused}
          keepDialogActiveOnMouseEnter={this.setDialogState}
          toolTipAnchorRef={this.toolTipAnchorRef}
          showDialog={this.state.showDialog}
          offset={this.props.offset}
          size={this.props.size}
          inverted={this.props.inverted}
          isIe={this.state.isIe}
          containerId={this.props.containerId}
          tooltipAnchorCoordinates={this.state.tooltipAnchorCoordinates}
        />
      );
    }

    return null;
  };

  renderIconAnchorElement = () => {
    const { iconConfig, colorConfig, focusState, disabled } = this.props;
    return (
      <TooltipIconWrapper
        tabIndex={-1}
        importantForAccessibility="no"
        onMouseEnter={disabled ? undefined : this.handleMouseEnter}
        onMouseDown={disabled ? undefined : this.handleMouseDown}
        onMouseLeave={disabled ? undefined : this.handleMouseExit}
        onMouseUp={disabled ? undefined : this.handleMouseUp}
        clicked={this.state.clicked}
        showDialog={this.state.showDialog}
        hovered={this.state.hovered}
      >
        <AnchorIconBase
          role="button"
          data-testid="tooltip"
          id={this.tooltipId}
          tabIndex={0}
          colorConfig={colorConfig}
          focusState={focusState}
          aria-describedby={this.ariaId}
          aria-labelledby={this.state.isiOS ? this.ariaId : null}
          aria-expanded={this.state.showDialog}
          aria-label={this.props.ariaLabel}
          hovered={this.state.hovered}
          clicked={this.state.clicked}
          focusable="false" // to make IE11 happy
          onFocus={!this.props.disabled ? this._onFocus : undefined}
          onKeyDown={
            !this.props.disabled ? this.handleKeyboardInput : undefined
          }
          secondary={this.props.secondary}
          type={this.props.type}
          showDialog={this.state.showDialog}
          size={this.props.size}
          inverted={this.props.inverted}
          keyboardFocused={this.state.keyboardFocused}
          onClick={this._onclick}
          disabled={this.props.disabled}
          {...{ [this.refKey]: elem => (this.toolTipAnchorRef = elem) }}
        >
          <span
            tabIndex={-1}
            style={{
              outline: 'none',
              display: 'inline-flex',
            }}
          >
            <AnchorIcon
              tabIndex={-1}
              colorConfig={colorConfig}
              iconConfig={iconConfig}
              disabled={this.props.disabled}
              onClick={this._onclick}
              importantForAccessibility="no"
              size={this.props.size}
              secondary={this.props.secondary}
              type={this.props.type}
              showDialog={this.state.showDialog}
              inverted={this.props.inverted}
              clicked={this.state.clicked}
              hovered={this.state.hovered}
              activeState={this.props.activeState}
              hoverState={this.props.hoverState}
              keyboardFocused={this.state.keyboardFocused}
              active={this.state.active}
            />
            {!this.props.disabled && (
              <HitArea
                tabIndex={-1}
                importantForAccessibility="no"
                data-testid="hit-area"
              />
            )}
            {this.renderTooltipDialog()}
          </span>
        </AnchorIconBase>
      </TooltipIconWrapper>
    );
  };

  renderCustomAnchorElement = () => {
    const computedProps = {
      onMouseEnter: this.handleMouseEnter,
      onMouseDown: this.handleMouseDown,
      onMouseLeave: this.handleMouseExit,
      onMouseUp: this.handleMouseUp,
      onKeyDown: this.handleKeyboardInput,
      onBlur: this.handleKeyboardInput,
    };

    const anchorWithRef = this.setAnchorElement();

    return (
      <CustomAnchorElementWrapper
        {...{ [this.refKey]: elem => (this.toolTipAnchorRef = elem) }}
        id={this.tooltipId}
        {...computedProps}
      >
        {React.cloneElement(anchorWithRef)}
        {this.renderTooltipDialog()}
      </CustomAnchorElementWrapper>
    );
  };

  render() {
    const { id, className } = this.props;
    return (
      <TooltipWrapper
        id={id}
        className={className}
        size={this.props.size}
        trailing={this.props.trailing}
      >
        {this.props.anchorElement || this.props.renderAnchorElement
          ? this.renderCustomAnchorElement()
          : this.renderIconAnchorElement()}
      </TooltipWrapper>
    );
  }
}

Tooltip.defaultProps = defaultProps;
Tooltip.propTypes = propTypes;

export default withVDSManager(Tooltip);
