import React, { Component } from 'react';
import PropTypes from 'prop-types';
import UNSAFE_SetEnvRef from '@uie/set-env-ref';
import styled, { css } from 'styled-components';
import ScrollView from './ScrollView';
import { calculateRem } from '@uie/javascript-style-helpers';
import { updateDialogPosition } from '../utils/position-util';
import vendorStyles from '../utils/vendorStyles';
import { BodyConfig, TypographyConfig } from '@vds-core/typography';
import { verizonTheme as theme, calculateSpacing } from '@vds-core/theme';

const propTypes = {
  /** String or function value for inner tooltip content . */
  content: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.array,
    PropTypes.node,
  ]),
  /** Boolean value to know if anchor has been clicked open . */
  clicked: PropTypes.bool,
  /** React Ref of tooltip anchor when custom anchor prop has been used */
  customAnchorElement: PropTypes.instanceOf(Element),
  /** Boolean to adjust dialog spacing based on if a custom anchor element has been passed */
  customAnchorPresent: PropTypes.bool,
  /** Method closes dialog active on mouseLeave. */
  deactivateDialogState: PropTypes.func,
  /** String value for inner tooltip heading. */
  header: PropTypes.string,
  /** id is a unique string for aria-labelledby */
  ariaId: PropTypes.string,
  /** Method keeps dialog active on mouseEnter. */
  keepDialogActiveOnMouseEnter: PropTypes.func,
  /** Boolean to track if keyboard has created focus. */
  keyboardFocused: PropTypes.bool,
  /** Number to create space between custom element and tooltip dialog element */
  offset: PropTypes.number,
  /** React Ref of tooltip anchor */
  toolTipAnchorRef: PropTypes.instanceOf(Element),
  /** String to check what size anchor element is being used */
  size: PropTypes.string,
  /** Boolean when true shows tooltip. */
  showDialog: PropTypes.bool,

  //added after renaming
  title: PropTypes.string,
  /**
   *
   *@ignore// inverted to change the border colors
   */
  inverted: PropTypes.bool,
  /**
   * Allows a unique component ID to be passed to the component as a reference for positioning other than the window object.
   */
  containerId: PropTypes.string,
};

const defaultProps = {
  content: null,
  showDialog: false,
  clicked: false,
  // customAnchorElement: () => {},
  customAnchorPresent: false,
  deactivateDialogState: false,
  header: null,
  ariaId: null,
  keepDialogActiveOnMouseEnter: false,
  keyboardFocused: false,
  offset: 0,
  toolTipAnchorRef: null,
  size: null,

  //added after rename
  title: null,
  inverted: false,
};

/*
fontWeightBold represents the font weight found in 
typography used when the component is bolded. Font weight is
not exported by typography configs due to the fact that 
typography components may have multiple font weight options
*/

const DialogWrapper = styled.span`
  ${vendorStyles};

  box-sizing: border-box;
  background-color: ${({ colorConfig }) => colorConfig.white};
  border: ${({ colorConfig }) =>
    `solid ${calculateRem(1)} ${colorConfig.black}`};
  color: ${({ colorConfig }) => colorConfig.black};
  left: ${({ positionDialog }) => positionDialog()};
  position: absolute;
  overflow: visible;
  padding: ${({ dialogPadding }) => dialogPadding};
  min-height: ${calculateRem(40)};
  max-height: ${calculateRem(214)};
  max-width: ${calculateRem(224)};
  -ms-overflow-style: none; /* disable scroll bar ie11*/
  text-align: left;
  transform: translateX(-50%);
  visibility: ${({ showDialog }) => (showDialog ? 'visible' : 'hidden')};
  width: ${calculateRem(224)};
  will-change: transform, left;
  z-index: ${({ clicked }) => (clicked ? 998 : 999)};
  outline: none;
  &::before {
    content: '';
    position: absolute;
    box-sizing: border-box;
    border-right: ${calculateRem(1)} solid
      ${({ inverted, colorConfig }) =>
        inverted ? colorConfig.white : colorConfig.black};
    border-bottom: ${calculateRem(1)} solid
      ${({ inverted, colorConfig }) =>
        inverted ? colorConfig.white : colorConfig.black};
    width: ${calculateRem(8.5)};
    height: ${calculateRem(8.5)};
    bottom: ${({ inverted }) =>
      inverted ? calculateRem(-3) : calculateRem(-4.5)};
    background: white;
    left: ${({ positionCaret }) => positionCaret()};

    transform: translate(-50%) rotate(45deg);
    will-change: transform, left;
    z-index: -1;
  }

  ${props => updateDialogPosition(props)};

  * ::-webkit-scrollbar {
    display: none;
  }

  * {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
`;

const HoverZone = styled.span`
  cursor: pointer;
  position: absolute;
  box-sizing: border-box;
  left: -1px;
  height: ${calculateRem(44)};
  width: ${calculateRem(224)};
  z-index: 1;
  ${({ isDialogOnTop }) =>
    isDialogOnTop &&
    `
    bottom: ${calculateRem(-44)};
    `};
  ${({ isDialogOnTop }) =>
    !isDialogOnTop &&
    `
    top: ${calculateRem(-44)};
    `};
`;

const sizeMap = {
  medium: 13,
  large: 13,
  small: 12,
};

const InnerDialogWithScroll = styled.span`
  display: inline-block;
  overflow: visible; /* necessary for ie11 support to show focus-state */
  position: relative;
`;

// focus state for inner dialog content
const InnerDialogWithScrollContentWrapper = styled.span`
  display: inline-block;
  width: ${calculateRem(200)};
  &:focus,
  &.js-focus-visible :focus:not(.focus-visible) {
    outline: none;

    &::after {
      content: '';
      border: ${({ keyboardFocused, colorConfig }) =>
        keyboardFocused
          ? `${calculateRem(1)} dotted ${colorConfig.black}`
          : ''};
      height: calc(100% - 28px);
      left: ${calculateRem(12)};
      position: absolute;
      width: ${calculateRem(198)};
      top: ${calculateRem(12)};
    }
  }

  span {
    -ms-overflow-style: none; /* Internet Explorer 10+ */
    scrollbar-width: none; /* Firefox */
  }

  span ::-webkit-scrollbar {
    /* Safari and Chrome */
    -webkit-appearance: none;
    width: 0px;
  }
`;

const InnerDialogWithoutScroll = styled.span`
  display: inline-block;
  width: 100%;
  outline: none;
  padding-right: 12px;
  box-sizing: border-box;
  &:focus {
    outline: none;
  }
`;

const TextWrapper = styled.span`
  ${({ isIe }) =>
    !isIe &&
    `
    flex-direction: column;
  `};
  display: inline;
  width: 100%;
`;

const StyledHeading = styled.span`
  display: flex;
  flex: 1;
  width: 100%;
  font-family: ${({ bodyConfig }) => bodyConfig.fontFamily};
  font-size: ${({ bodyConfig }) => calculateRem(bodyConfig.fontSize)};
  line-height: ${({ bodyConfig }) => calculateRem(bodyConfig.lineHeight)};
  letter-spacing: ${({ bodyConfig }) =>
    bodyConfig.letterSpacing && calculateRem(bodyConfig.letterSpacing)};
  margin: 0;
  font-weight: ${({ typescale }) => (typescale === 'VDS' ? 700 : 'bold')};
  margin-bottom: ${calculateSpacing('1X')};
`;

const StyledContent = styled.span`
  display: flex;
  flex: 1;
  width: 100%;
  height: 100%;
  font-family: ${({ bodyConfig }) => bodyConfig.fontFamily};
  font-size: ${({ bodyConfig }) => calculateRem(bodyConfig.fontSize)};
  line-height: ${({ bodyConfig }) => calculateRem(bodyConfig.lineHeight)};
  letter-spacing: ${({ bodyConfig }) =>
    bodyConfig.letterSpacing && calculateRem(bodyConfig.letterSpacing)};
  margin: 0;
`;

/**
 * @ignore
 */
class TooltipDialog extends Component {
  state = {
    isDialogOnTop: true,
    dialogHorizontalPosition: 0,
    tooltipDialogContentHeight: 0,
    dialogElementCoordinates: {},
    size: this.props.size,
  };

  componentDidMount = () => {
    this.doUpdatedCoordinates = true;
    window.addEventListener('scroll', this.setElementsProperties);
    window.addEventListener('resize', this.setElementsProperties);
    this.setElementsProperties();
    this.tooltipDialogContentHeight();
    this.positionDialogContentVertical();
  };

  componentDidUpdate = () => {
    if (this.doUpdatedCoordinates) {
      this.setElementsProperties();
      this.positionDialogContentHorizontal();
      // toggle doUpdateCoordinates flag to protect against infinite re-renders
      this.doUpdatedCoordinates = false;
    }
  };

  refKey = UNSAFE_SetEnvRef();

  componentWillUnmount = () => {
    window.removeEventListener('scroll', this.setElementsProperties);
    window.removeEventListener('resize', this.setElementsProperties);
  };

  setElementsProperties = () => {
    this.setDialogElementPositionProperties();
  };

  setDialogElementPositionProperties = () => {
    /**
     * getBoundingRect of the tooltip dialog if coords have been updated
     * if no update take from state
     */
    const dialogElementRef = this.tooltipContentRef;

    const dialogElementCoordinates = dialogElementRef.getBoundingClientRect();

    this.setState({ dialogElementCoordinates });
  };

  positionDialogContentVertical = () => {
    const currentAnchorCoordinates = this.props.tooltipAnchorCoordinates;
    const tooltipContentWithGutter = this.tooltipContentRef.offsetHeight;
    const containerNode =
      this.props.containerId && document.getElementById(this.props.containerId);
    let contentOverflowsTop = false;

    if (containerNode) {
      const parentDistanceFromTop = containerNode.getBoundingClientRect().top;
      const dialogDistanceFromTop =
        this.tooltipContentRef &&
        this.tooltipContentRef.getBoundingClientRect().top;
      contentOverflowsTop = dialogDistanceFromTop < parentDistanceFromTop;
    }

    const roomForDialogAboveAnchor =
      currentAnchorCoordinates.top &&
      currentAnchorCoordinates.top > tooltipContentWithGutter;

    if (!roomForDialogAboveAnchor || contentOverflowsTop) {
      this.setState({ isDialogOnTop: false });
    } else {
      this.setState({ isDialogOnTop: true });
    }
  };

  positionDialogContentHorizontal = () => {
    const gutter = 20;
    const {
      left: anchorDistanceFromLeft,
    } = this.props.tooltipAnchorCoordinates;
    const {
      width: dialogElementWidth,
      left: dialogDistaceFromLeft,
      right: dialogDistanceFromRight,
    } = this.state.dialogElementCoordinates;

    const halfDialogWidth = dialogElementWidth / 2;
    const dialogNearRight =
      window.innerWidth - gutter - dialogDistaceFromLeft - halfDialogWidth;
    const maxPos = halfDialogWidth - gutter + 4;
    const offset = this.state.size ? sizeMap[this.state.size] : 0;
    const containerNode =
      this.props.containerId && document.getElementById(this.props.containerId);

    if (containerNode) {
      const containerRect = containerNode.getBoundingClientRect();
      const moveLeft =
        dialogDistanceFromRight + gutter > containerRect.right ? true : false;
      const moveRight =
        dialogDistaceFromLeft - gutter < containerRect.left ? true : false;
      let dialogHorizontalPosition = 0;

      if (moveRight) {
        dialogHorizontalPosition =
          containerRect.left - dialogDistaceFromLeft + gutter;
      }
      if (moveLeft) {
        dialogHorizontalPosition =
          containerRect.right - dialogDistanceFromRight - gutter;
      }

      this.setState({ dialogHorizontalPosition });
      return;
    }

    if (halfDialogWidth > anchorDistanceFromLeft) {
      // if the anchorElement is <= 20px from left set both the arrow and
      // dialog to current position
      const dialogHorizontalPosition =
        anchorDistanceFromLeft <= gutter
          ? halfDialogWidth - gutter + offset
          : halfDialogWidth - anchorDistanceFromLeft + offset;

      this.setState({ dialogHorizontalPosition });
    } else if (halfDialogWidth > dialogNearRight) {
      //  flip negative to positive to check against maxPos
      const dialogHorizontalPosition =
        Math.abs(dialogNearRight - halfDialogWidth) > maxPos
          ? -1 * maxPos + offset
          : dialogNearRight - halfDialogWidth + offset;

      this.setState({ dialogHorizontalPosition });
    } else {
      this.setState({ dialogHorizontalPosition: 0 });
    }
  };

  tooltipDialogContentHeight = () => {
    // get the height of dialog content, allows scroll bar to render if height is > 212px
    let tooltipDialogContentHeight = this.tooltipContentRef.offsetHeight - 1;
    this.setState({ tooltipDialogContentHeight });
  };

  handleDialogUnFocus = e => {
    // if keyDown === enter || tab deactivate dialog
    if (e.keyCode === 13 || e.keyCode === 9) {
      this.props.deactivateDialogState();
    }
  };

  _positionCaret = () => {
    let position = this.state.dialogHorizontalPosition;
    let leftOffset = position;

    if (position > 93) leftOffset = 94;
    if (position < -93) leftOffset = -94;

    return `calc(50% - ${leftOffset}px);`; //106 is each edge - include this a scrollable div
  };

  _positionDialog = () => {
    let position = this.state.dialogHorizontalPosition;
    let leftOffset = position;

    if (position > 93) leftOffset = 94;
    if (position < -93) leftOffset = -94;

    return `calc(50% + ${leftOffset}px);`; //106 is each edge - include this a scrollable div
  };

  _onScroll = event => {
    this.props.setScrollPosition(event.currentTarget.scrollTop);
  };

  // flag for componentDidUpdate to update current position coords of anchor and dialog
  doUpdatedCoordinates = true;

  renderTooltipDialogWithScroll = e => {
    let bodyConfig = this.props.bodyConfig.getStyles(
      this.props.typescale,
      'desktop',
      'small'
    );
    return (
      <InnerDialogWithScroll>
        <InnerDialogWithScrollContentWrapper
          colorConfig={this.props.colorConfig}
          id={this.props.ariaId}
          // unset focus state so user can close dialog with keyboard
          // user can can scroll || leave with keyboard
          onKeyDown={this.handleDialogUnFocus}
          keyboardFocused={this.props.keyboardFocused}
        >
          <ScrollView>
            {(this.props.header || this.props.title) && (
              <StyledHeading bodyConfig={bodyConfig}>
                {this.props.header
                  ? this.props.header
                  : this.props.title && this.props.title}
              </StyledHeading>
            )}
            {this.props.content && (
              <StyledContent bodyConfig={bodyConfig}>
                {this.props.content}
              </StyledContent>
            )}
          </ScrollView>
        </InnerDialogWithScrollContentWrapper>
      </InnerDialogWithScroll>
    );
  };

  renderDialogWithoutScroll = () => {
    let bodyConfig = this.props.bodyConfig.getStyles(
      this.props.typescale,
      'desktop',
      'small'
    );
    const { isIe } = this.props;

    return (
      <InnerDialogWithoutScroll
        role="tooltip"
        dialogPadding={this.props.dialogPadding}
        onKeyDown={this.handleDialogUnFocus}
        tabIndex={-1}
        id={this.props.ariaId}
      >
        <TextWrapper isIe={isIe}>
          {(this.props.header || this.props.title) && (
            <StyledHeading
              bodyConfig={bodyConfig}
              typescale={this.props.typescale}
            >
              {this.props.header
                ? this.props.header
                : this.props.title && this.props.title}
            </StyledHeading>
          )}
          {this.props.content && (
            <StyledContent bodyConfig={bodyConfig}>
              {this.props.content}
            </StyledContent>
          )}
        </TextWrapper>
      </InnerDialogWithoutScroll>
    );
  };

  render() {
    const { dialogElementCoordinates } = this.state;
    const { tooltipAnchorCoordinates } = this.props;
    return (
      <DialogWrapper
        dialogPadding={this.props.dialogPadding}
        positionCaret={this._positionCaret}
        positionDialog={this._positionDialog}
        anchorElemTop={tooltipAnchorCoordinates.top}
        anchorElemWidth={tooltipAnchorCoordinates.width}
        className="persistentScrollbar"
        customAnchorElement={this.props.customAnchorElement}
        customAnchorPresent={this.props.customAnchorPresent}
        clicked={this.props.clicked}
        data-testid="dialog"
        dialogElementBottom={dialogElementCoordinates.bottom}
        dialogElementTop={dialogElementCoordinates.top}
        dialogElementWidth={dialogElementCoordinates.width}
        dialogHorizontalPosition={this.state.dialogHorizontalPosition}
        isDialogOnTop={this.state.isDialogOnTop}
        onClick={this.props.onClick}
        onMouseEnter={this.props.keepDialogActiveOnMouseEnter}
        aria-hidden={!this.props.showDialog}
        // dialog has been clicked don't close dialog on mouse out
        onMouseLeave={
          this.props.clicked ? null : this.props.deactivateDialogState
        }
        // eslint-disable-next-line no-return-assign
        {...{ [this.refKey]: elem => (this.tooltipContentRef = elem) }}
        role="none"
        size={this.props.size}
        offset={this.props.offset}
        showDialog={this.props.showDialog}
        colorConfig={this.props.colorConfig}
        inverted={this.props.inverted}
      >
        {this.state.tooltipDialogContentHeight > 212
          ? this.renderTooltipDialogWithScroll()
          : this.renderDialogWithoutScroll()}
        <HoverZone
          isDialogOnTop={this.state.isDialogOnTop}
          importantForAccessibility="no"
          data-testid="hover-zone"
        />
      </DialogWrapper>
    );
  }
}

TooltipDialog.defaultProps = defaultProps;
TooltipDialog.propTypes = propTypes;

export default TooltipDialog;
