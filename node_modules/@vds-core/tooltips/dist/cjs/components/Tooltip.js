"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _taggedTemplateLiteral2 = _interopRequireDefault(require("@babel/runtime/helpers/taggedTemplateLiteral"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _setEnvRef = _interopRequireDefault(require("@uie/set-env-ref"));

var _styledComponents = _interopRequireWildcard(require("styled-components"));

var _cuid = _interopRequireDefault(require("cuid"));

var _javascriptStyleHelpers = require("@uie/javascript-style-helpers");

var _AnchorIconBase = _interopRequireDefault(require("./AnchorIconBase"));

var _TooltipDialog = _interopRequireDefault(require("./TooltipDialog"));

var _AnchorIcon = _interopRequireDefault(require("../utils/AnchorIcon"));

var _icons = require("@vds-core/icons");

var _typography = require("@vds-core/typography");

var _theme = require("@vds-core/theme");

var _utilities = require("@vds-core/utilities");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _templateObject6() {
  var data = (0, _taggedTemplateLiteral2["default"])(["\n&&& {\n  transform: translate(-50%, -50%);\n  text-align: center;\n  cursor: pointer;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  bottom: 50%;\n  height: ", ";\n  width: ", ";\n  z-index: 1;\n}\n"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = (0, _taggedTemplateLiteral2["default"])(["\n&&& {\n  transform: translate(-50%, -50%);\n  text-align: center;\n  cursor: pointer;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  bottom: 50%;\n  height: ", ";\n  width: ", ";\n  z-index: 1;\n  outline: none;\n}\n"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = (0, _taggedTemplateLiteral2["default"])(["\n&&& {\n  position: absolute;\n  outline: none;\n}\n"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = (0, _taggedTemplateLiteral2["default"])(["\n&&& {\n  display: inline-block;\n  position: relative;\n}\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = (0, _taggedTemplateLiteral2["default"])(["\n&&& {\n  display: flex;\n  flex-direction: column;\n  outline: none;\n  z-index: ", ";\n}\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = (0, _taggedTemplateLiteral2["default"])(["\n&&& {\n  display: inline-flex;\n  align-items: center;\n  position: relative;\n  padding: 0;\n  outline: none;\n  ", ";\n}\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

var propTypes = {
  /**
   * @deprecated
   * Function that returns an HTML element or React component to be used as a custom anchor for the tooltip. The function is called with a React ref, and an object that will pass back aria-describedby and aria-expanded that has to be passed to the returned anchor element/component.
   */
  anchorElement: _propTypes["default"].func,

  /**
   * String, React Component, or HTML to rendered as the body of the tooltip.
   */
  children: _propTypes["default"].any,

  /**
   * @deprecated
   * String, React Component, or HTML to rendered as the header of the tooltip.
   */
  header: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].func]),

  /**
   * @deprecated
   * Boolean used to choose secondary version of icon element. <strong>Can only be used with <code>base icon element
   */
  secondary: _propTypes["default"].bool,

  /**
   * Boolean used to invert icon element color.<strong>Can only be used with <code>base icon element</code></strong>
   */
  inverted: _propTypes["default"].bool,

  /**
   * Size of icon
   */
  size: _propTypes["default"].string,

  /**
   * Number used as a pixel value to offset space between tooltip and <code>anchorElement</code>. <strong>Can only be used with <code>anchorElement</code></strong>
   */
  offset: _propTypes["default"].number,

  /**
   * String used to choose secondary or primary version of icon element. <strong>Can only be used with <code>base icon element</code></strong>
   */
  type: _propTypes["default"].string,

  /**
   * String, React Component, or HTML to rendered as the header of the tooltip.
   */
  title: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].func]),

  /**
   * A String label that is required for accessibility, the should be very terse description ot the tooltips content.
   */
  ariaLabel: _propTypes["default"].string,

  /**
   * Function that returns an HTML element or React component to be used as a custom anchor for the tooltip. The function is called with a React ref, and an object that will pass back aria-describedby, aria-expanded, and aria-label that has to be passed to the returned anchor element/component.
   */
  renderAnchorElement: _propTypes["default"].func,

  /**
   *@ignore
   *Icon package used to render info icon as anchor
   */
  iconConfig: _propTypes["default"].object,

  /**
   *@ignore
   *Enables focus state with dashed lines
   */
  focusState: _propTypes["default"].bool,
  //todo:

  /**
   *@ignore
   *Enables hover state with medium weight icon
   */
  hoverState: _propTypes["default"].bool,

  /**
   *@ignore
   *Enables grey medium weight icon on active
   */
  activeState: _propTypes["default"].bool,

  /**
   *@ignore
   *configuration for body component
   */
  bodyConfig: _propTypes["default"].object,

  /**
   *@ignore
   *configuration for body component
   */
  colorConfig: _propTypes["default"].object,

  /**
   *
   *@ignore// typescale for body config
   */
  typescale: _propTypes["default"].string,

  /**
   *
   *@ignore// padding for inside of dialog
   */
  dialogPadding: _propTypes["default"].string,

  /**
   * Allows a unique ID to be passed to the component.
   */
  id: _propTypes["default"].string,

  /**
   * Boolean that activates disabled state
   */
  disabled: _propTypes["default"].bool,

  /**
   * Allows a unique component ID to be passed to the component as a reference for positioning other than the window object.
   */
  containerId: _propTypes["default"].string
};
var defaultProps = {
  anchorElement: null,
  header: null,
  secondary: false,
  inverted: false,
  size: 'large',
  offset: 0,
  //added after renaming
  type: null,
  title: null,
  ariaLabel: 'More information',
  renderAnchorElement: null,
  iconConfig: _icons.IconData,
  focusState: false,
  hoverState: false,
  activeState: false,
  bodyConfig: _typography.BodyConfig,
  typescale: _typography.TypographyConfig.getTypescale(),
  dialogPadding: (0, _javascriptStyleHelpers.calculateRem)(12, 0, 16, 12),
  colorConfig: _theme.colors,
  disabled: false
};
var ARIA_LIVE_VALUE = 'polite';

var TooltipWrapper = /*#__PURE__*/_styledComponents["default"].span.withConfig({
  componentId: "VDS__sc-8y4bkd-0"
})(_templateObject(), function (_ref) {
  var disabled = _ref.disabled;
  return disabled && "\n    pointer-events: none;\n    cursor: default;\n  ";
});

var TooltipIconWrapper = /*#__PURE__*/_styledComponents["default"].span.withConfig({
  componentId: "VDS__sc-8y4bkd-1"
})(_templateObject2(), function (_ref2) {
  var clicked = _ref2.clicked,
      showDialog = _ref2.showDialog,
      hovered = _ref2.hovered;
  return clicked || hovered || showDialog ? 2 : 0;
});

var CustomAnchorElementWrapper = /*#__PURE__*/_styledComponents["default"].span.withConfig({
  componentId: "VDS__sc-8y4bkd-2"
})(_templateObject3());

var IconPositionWrapper = /*#__PURE__*/_styledComponents["default"].span.withConfig({
  componentId: "VDS__sc-8y4bkd-3"
})(_templateObject4());

var HitArea = /*#__PURE__*/_styledComponents["default"].span.withConfig({
  componentId: "VDS__sc-8y4bkd-4"
})(_templateObject5(), (0, _javascriptStyleHelpers.calculateRem)(44), (0, _javascriptStyleHelpers.calculateRem)(44));

var HoverZone = /*#__PURE__*/_styledComponents["default"].span.withConfig({
  componentId: "VDS__sc-8y4bkd-5"
})(_templateObject6(), (0, _javascriptStyleHelpers.calculateRem)(44), (0, _javascriptStyleHelpers.calculateRem)(228));

function _isiOS() {
  var isIPAD = navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1 && !window.MSStream;
  var isMobileDevice = /iPhone|iPad/i.test(navigator.userAgent);
  return isMobileDevice || isIPAD;
}

function _checkIfIe() {
  var ua = window.navigator.userAgent;
  var msie = ua.indexOf('MSIE ');

  if (msie > 0) {
    // IE 10 or older => return version number
    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
  }

  var trident = ua.indexOf('Trident/');

  if (trident > 0) {
    // IE 11 => return version number
    var rv = ua.indexOf('rv:');
    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
  }

  var edge = ua.indexOf('Edge/');

  if (edge > 0) {
    // Edge => return version number
    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
  } // other browser


  return false;
}

var Tooltip = /*#__PURE__*/function (_Component) {
  (0, _inherits2["default"])(Tooltip, _Component);

  var _super = _createSuper(Tooltip);

  function Tooltip() {
    var _this;

    (0, _classCallCheck2["default"])(this, Tooltip);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "state", {
      hovered: false,
      keyboardFocused: false,
      showDialog: false,
      clicked: false,
      hoveredWhenFocused: false,
      active: false,
      customAnchorPresent: false,
      isIe: _checkIfIe(),
      isiOS: _isiOS(),
      scrollPosition: null,
      expanded: false,
      tooltipAnchorCoordinates: {}
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "componentDidMount", function () {
      document.addEventListener('click', _this.handleClickOutside);
      window.addEventListener('scroll', _this.setAnchorElementPositionProperties());
      window.addEventListener('resize', _this.setAnchorElementPositionProperties()); // this check is to see if a custom element is being used as an anchor
      // this flag will activate different styles for the dialog based on the boolean

      if (_this.props.anchorElement || _this.props.renderAnchorElement) {
        _this.setState({
          customAnchorPresent: true
        });
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "componentDidUpdate", function (prevProps, prevState) {
      if (prevState.showDialog !== _this.state.showDialog) {
        document.getElementById(_this.tooltipId).focus();
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "componentWillUnmount", function () {
      document.removeEventListener('click', _this.handleClickOutside);
      window.removeEventListener('scroll', _this.setAnchorElementPositionProperties());
      window.removeEventListener('resize', _this.setAnchorElementPositionProperties());
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setAnchorElementPositionProperties", function () {
      // get the reference to the current tooltipAnchor
      var tooltipAnchor = _this.toolTipAnchorRef;
      var tooltipAnchorRef = tooltipAnchor;
      var tooltipAnchorCoordinates = tooltipAnchorRef.getBoundingClientRect(); // assign tooltipAnchorCoordinates the value of the current anchor ref boundingClientRect

      _this.setState({
        tooltipAnchorCoordinates: tooltipAnchorCoordinates
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setDialogState", function () {
      return _this.setState({
        showDialog: true
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setClickedState", function () {
      return _this.setState(function (prevState) {
        return {
          clicked: !prevState.clicked
        };
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "deactivateDialogState", function () {
      return _this.setState({
        showDialog: false
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "deactivateClickedState", function () {
      return _this.setState({
        keyboardFocused: false,
        forceClose: false
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "handleKeyboardInput", function (e, focused) {
      var showDialog = _this.state.showDialog;
      if (e.keyCode === 32) e.preventDefault(); //For the new passthrough icon focus

      if (_this.props.focusState && focused && !_this.state.keyboardFocused && !_this.state.clicked && !_this.state.showDialog) {
        _this.setState({
          keyboardFocused: !_this.state.keyboardFocused
        });
      } else if (_this.props.focusState && !focused && _this.state.keyboardFocused) {
        _this.setState({
          keyboardFocused: !_this.state.keyboardFocused
        });
      }

      if (e.keyCode === 13 || e.keyCode === 32 || // return key
      e.keyCode === 27 && showDialog // esc key
      ) {
          _this.setState({
            // toggle showDialog state based on keyboard interaction
            showDialog: !_this.state.showDialog,
            keyboardFocused: !_this.state.keyboardFocused,
            expanded: !_this.state.expanded
          });
        } else if (e.shiftKey && e.keyCode === 9) {
        _this.deactivateDialogState(); // deactivate dialog if user shift tabs

      } else if (e.keyCode === 9 && _this.showDialog) {
        _this.deactivateDialogState(); // deactivate dialog if use tabs away

      } else if (e.keyCode === 9) {
        _this.setState({
          keyboardFocused: !_this.state.keyboardFocused
        });
      }

      if (_this.anchorWithRef !== null && _this.anchorElementProps.props.onKeyDown) {
        _this.anchorElementProps.props.onKeyDown(e);
      }

      if (_this.anchorWithRef !== null && _this.anchorElementProps.props.onBlur) {
        _this.anchorElementProps.props.onBlur(e);
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "handleClickOutside", function (e) {
      // check if current event contains ref if not close dialog
      var toolTipAnchorRef = _this.toolTipAnchorRef;

      if (toolTipAnchorRef && !toolTipAnchorRef.contains(e.target)) {
        _this.deactivateDialogState();

        _this.deactivateClickedState();

        _this.setState({
          scrollPosition: 0
        });

        if (_this.state.clicked) {
          _this.setClickedState();
        }
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "handleMouseEnter", function (e) {
      if (_this.state.keyboardFocused) {
        _this.setState({
          hoveredWhenFocused: true,
          keyboardFocused: false
        });
      }

      if (_this.state.showDialog && _this.state.clicked) {
        _this.setState({
          hovered: true
        });

        return;
      }

      _this.openTooltipTimeout = setTimeout(function () {
        _this.setState({
          showDialog: true,
          hovered: true
        });
      }, 200);

      if (_this.anchorWithRef !== null && _this.anchorElementProps.props.onMouseEnter) {
        _this.anchorElementProps.props.onMouseEnter(e);
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "handleMouseExit", function (e) {
      if (_this.state.clicked && _this.state.showDialog) {
        return;
      } // clear time out to prevent showDialog being set to true unintentionally


      clearTimeout(_this.openTooltipTimeout);

      _this.setState({
        hovered: false,
        showDialog: false,
        forceClose: false
      });

      if (_this.anchorWithRef !== null && _this.anchorElementProps.props.onMouseLeave) {
        _this.anchorElementProps.props.onMouseLeave(e);
      }

      if (_this.state.hoveredWhenFocused) {
        _this.setState({
          hoveredWhenFocused: false,
          keyboardFocused: true
        });
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "handleMouseDown", function (e) {
      _this.setState({
        active: true
      });

      if (_this.state.clicked) {
        _this.setState({
          forceClose: true
        });
      }

      _this.deactivateDialogState();

      _this.setDialogState();

      _this.setClickedState();

      if (_this.anchorWithRef !== null && _this.anchorElementProps.props.onMouseDown) {
        _this.anchorElementProps.props.onMouseDown(e);
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "handleMouseUp", function (e) {
      _this.setState({
        active: false
      });

      if (_this.state.forceClose) {
        _this.deactivateDialogState();

        _this.deactivateClickedState();

        e.currentTarget.blur();
      }

      if (_this.anchorWithRef !== null && _this.anchorElementProps.props.onMouseUp) {
        _this.anchorElementProps.props.onMouseUp(e);
      }
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onFocus", function (e) {
      _this.handleKeyboardInput(e, true);
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setAnchorElement", function () {
      var computedProps = _objectSpread({
        ariaDescribedBy: _this.ariaId,
        ariaExpanded: _this.state.showDialog,
        ariaLabel: _this.state.ariaLabel,
        ariaLive: ARIA_LIVE_VALUE
      }, (0, _defineProperty2["default"])({}, _this.refKey, function (elem) {
        return _this.toolTipAnchorRef = elem;
      }));

      if (_this.props.anchorElement) {
        return _this.props.anchorElement(computedProps);
      } else if (_this.props.renderAnchorElement) {
        return _this.props.renderAnchorElement(computedProps);
      }

      return null;
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_setScrollPosition", function (y) {
      _this.setState({
        scrollPosition: y
      });
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "refKey", (0, _setEnvRef["default"])());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "ariaId", "tooltip-".concat((0, _cuid["default"])()));
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "tooltipId", (0, _cuid["default"])());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "anchorWithRef", _this.setAnchorElement());
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "anchorElementProps", _this.anchorWithRef);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "renderTooltipDialog", function () {
      if (_this.state.showDialog && !_this.props.disabled) {
        return /*#__PURE__*/_react["default"].createElement(_TooltipDialog["default"], {
          scrollPosition: _this.state.scrollPosition,
          setScrollPosition: _this._setScrollPosition,
          colorConfig: _this.props.colorConfig,
          bodyConfig: _this.props.bodyConfig,
          typescale: _this.props.typescale,
          dialogPadding: _this.props.dialogPadding,
          clicked: _this.state.clicked,
          customAnchorElement: _this.toolTipAnchorRef,
          customAnchorPresent: _this.state.customAnchorPresent,
          content: _this.props.children,
          deactivateDialogState: _this.deactivateDialogState,
          header: _this.props.header,
          title: _this.props.title,
          ariaId: _this.ariaId,
          keyboardFocused: _this.state.keyboardFocused,
          keepDialogActiveOnMouseEnter: _this.setDialogState,
          toolTipAnchorRef: _this.toolTipAnchorRef,
          showDialog: _this.state.showDialog,
          offset: _this.props.offset,
          size: _this.props.size,
          inverted: _this.props.inverted,
          isIe: _this.state.isIe,
          containerId: _this.props.containerId,
          tooltipAnchorCoordinates: _this.state.tooltipAnchorCoordinates
        });
      }

      return null;
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "renderIconAnchorElement", function () {
      var _this$props = _this.props,
          iconConfig = _this$props.iconConfig,
          colorConfig = _this$props.colorConfig,
          focusState = _this$props.focusState,
          disabled = _this$props.disabled;
      return /*#__PURE__*/_react["default"].createElement(TooltipIconWrapper, {
        tabIndex: -1,
        importantForAccessibility: "no",
        onMouseEnter: disabled ? undefined : _this.handleMouseEnter,
        onMouseDown: disabled ? undefined : _this.handleMouseDown,
        onMouseLeave: disabled ? undefined : _this.handleMouseExit,
        onMouseUp: disabled ? undefined : _this.handleMouseUp,
        clicked: _this.state.clicked,
        showDialog: _this.state.showDialog,
        hovered: _this.state.hovered
      }, /*#__PURE__*/_react["default"].createElement(_AnchorIconBase["default"], (0, _extends2["default"])({
        role: "button",
        "data-testid": "tooltip",
        id: _this.tooltipId,
        tabIndex: 0,
        colorConfig: colorConfig,
        focusState: focusState,
        "aria-describedby": _this.ariaId,
        "aria-labelledby": _this.state.isiOS ? _this.ariaId : null,
        "aria-expanded": _this.state.showDialog,
        "aria-label": _this.props.ariaLabel,
        hovered: _this.state.hovered,
        clicked: _this.state.clicked,
        focusable: "false" // to make IE11 happy
        ,
        onFocus: !_this.props.disabled ? _this._onFocus : undefined,
        onKeyDown: !_this.props.disabled ? _this.handleKeyboardInput : undefined,
        secondary: _this.props.secondary,
        type: _this.props.type,
        showDialog: _this.state.showDialog,
        size: _this.props.size,
        inverted: _this.props.inverted,
        keyboardFocused: _this.state.keyboardFocused,
        onClick: _this._onclick,
        disabled: _this.props.disabled
      }, (0, _defineProperty2["default"])({}, _this.refKey, function (elem) {
        return _this.toolTipAnchorRef = elem;
      })), /*#__PURE__*/_react["default"].createElement("span", {
        tabIndex: -1,
        style: {
          outline: 'none',
          display: 'inline-flex'
        }
      }, /*#__PURE__*/_react["default"].createElement(_AnchorIcon["default"], {
        tabIndex: -1,
        colorConfig: colorConfig,
        iconConfig: iconConfig,
        disabled: _this.props.disabled,
        onClick: _this._onclick,
        importantForAccessibility: "no",
        size: _this.props.size,
        secondary: _this.props.secondary,
        type: _this.props.type,
        showDialog: _this.state.showDialog,
        inverted: _this.props.inverted,
        clicked: _this.state.clicked,
        hovered: _this.state.hovered,
        activeState: _this.props.activeState,
        hoverState: _this.props.hoverState,
        keyboardFocused: _this.state.keyboardFocused,
        active: _this.state.active
      }), !_this.props.disabled && /*#__PURE__*/_react["default"].createElement(HitArea, {
        tabIndex: -1,
        importantForAccessibility: "no",
        "data-testid": "hit-area"
      }), _this.renderTooltipDialog())));
    });
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "renderCustomAnchorElement", function () {
      var computedProps = {
        onMouseEnter: _this.handleMouseEnter,
        onMouseDown: _this.handleMouseDown,
        onMouseLeave: _this.handleMouseExit,
        onMouseUp: _this.handleMouseUp,
        onKeyDown: _this.handleKeyboardInput,
        onBlur: _this.handleKeyboardInput
      };

      var anchorWithRef = _this.setAnchorElement();

      return /*#__PURE__*/_react["default"].createElement(CustomAnchorElementWrapper, (0, _extends2["default"])({}, (0, _defineProperty2["default"])({}, _this.refKey, function (elem) {
        return _this.toolTipAnchorRef = elem;
      }), {
        id: _this.tooltipId
      }, computedProps), /*#__PURE__*/_react["default"].cloneElement(anchorWithRef), _this.renderTooltipDialog());
    });
    return _this;
  }

  (0, _createClass2["default"])(Tooltip, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          id = _this$props2.id,
          className = _this$props2.className;
      return /*#__PURE__*/_react["default"].createElement(TooltipWrapper, {
        id: id,
        className: className,
        size: this.props.size,
        trailing: this.props.trailing
      }, this.props.anchorElement || this.props.renderAnchorElement ? this.renderCustomAnchorElement() : this.renderIconAnchorElement());
    }
  }]);
  return Tooltip;
}(_react.Component);

Tooltip.defaultProps = defaultProps;
Tooltip.propTypes = propTypes;

var _default = (0, _utilities.withVDSManager)(Tooltip);

exports["default"] = _default;