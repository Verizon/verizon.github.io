import _taggedTemplateLiteral from "@babel/runtime/helpers/taggedTemplateLiteral";

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n&&& {\n  display: inline-flex;\n  vertical-align: middle;\n  position: relative;\n  top: ", "px;\n}\n"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n&&& {\n  display: inline-block;\n  outline: none;\n}\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n&&& {\n  font-weight: 400;\n}\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n&&& {\n  display: inline-flex;\n  align-items: center;\n}\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

import React, { Fragment } from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import Tooltip from './Tooltip';
import { colors } from '@vds/theme';
import { calculateRem } from '@uie/javascript-style-helpers';
var propTypes = {
  /**
   * Content that will be passed to the typography.
   */
  children: PropTypes.string,

  /**
   * Primitive used for the typgraphy.
   */
  typographyType: PropTypes.oneOf(['title', 'subtitle', 'body', 'micro']),

  /**
   * Primitive used for the typgraphy.
   */
  typographyPrimitive: PropTypes.oneOf(['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'span', 'p']),

  /**
   * Viewport the font styling is based on. Desktop and tablet are the same size.
   */
  viewport: PropTypes.oneOf(['desktop', 'tablet', 'mobile']),

  /**
   * Size of the typography component to be rendered.
   */
  typographySize: PropTypes.string,

  /**
   * Color of the typography component to be rendered.
   */
  typographyColor: PropTypes.string,

  /**
   * Adds a fontWeight of bold to the typography component, only valid for Body and Title typographyTypes.
   */
  bold: PropTypes.bool,

  /**
   * Determines the size of the tooltip
   */
  tooltipSize: PropTypes.oneOf(['small', 'large']),

  /**
   * Determines the content of the tooltip
   */
  tooltipContent: PropTypes.any,

  /**
   * Determines the title of the tooltip
   */
  tooltipTitle: PropTypes.string,

  /**
   * @ignore Passes in VDS Body component
   */
  Body: PropTypes.func,

  /**
   * @ignore Passes in VDS Body component
   */
  Micro: PropTypes.func,

  /**
   * @ignore Passes in VDS Body component
   */
  Title: PropTypes.func,

  /**
   * @ignore Passes in VDS Body component
   */
  Subtitle: PropTypes.func,

  /**
   * @ignore Passes in VDS Body font configuration
   */
  bodyConfig: PropTypes.object,

  /**
   * @ignore Passes in VDS color configuration
   */
  colorConfig: PropTypes.object,

  /**
   * @ignore Passes in VDS icon configuration
   */
  iconConfig: PropTypes.object
};
var defaultProps = {
  typographyType: 'body',
  viewport: 'desktop',
  typographySize: 'small',
  tooltipSize: 'small'
};
var ChildWrapper = /*#__PURE__*/styled.span.withConfig({
  componentId: "VDS__stn7mq-0"
})(_templateObject());
var TooltipContent = /*#__PURE__*/styled.span.withConfig({
  componentId: "VDS__stn7mq-1"
})(_templateObject2());
var StyledSpan = /*#__PURE__*/styled.span.withConfig({
  componentId: "VDS__stn7mq-2"
})(_templateObject3());
var InlineWrapper = /*#__PURE__*/styled.span.withConfig({
  componentId: "VDS__stn7mq-3"
})(_templateObject4(), function (_ref) {
  var type = _ref.type;
  return type === 'body' || type === 'micro' ? 0 : 1;
});

function _formatChildren(childArray) {
  var textWithoutIcon = '';
  childArray.map(function (item, index) {
    if (index !== childArray.length - 1) {
      textWithoutIcon += item + ' ';
    }
  });
  return textWithoutIcon;
}

function checkForNode(children) {
  var lastIndex = children.length - 1,
      //number of last index in child array
  lastChild = children[lastIndex],
      //last child in child array
  isNode = typeof children[lastIndex] !== 'string',
      //if last child is node
  isString = typeof children === 'string',
      //if children are a string
  firstNodes = [];
  if (children.length === undefined || children.length <= 1) return {
    childArray: [],
    textWithIcon: children
  }; //if only one child put with caret and return

  if (isNode || !isString) {
    //if the last child is node or mixture put last with the caret
    children.map(function (child, index) {
      //add all children to first nodes except the last one
      if (index !== lastIndex) firstNodes[index] = child;
    });
    return {
      childArray: firstNodes,
      textWithIcon: lastChild
    };
  } //if all children are "strings", put last word with caret


  var childArray = children.split(' ');
  var textWithIcon = childArray[childArray.length - 1];
  return {
    childArray: _formatChildren(childArray),
    textWithIcon: textWithIcon
  };
}

function _renderWithIcon(props) {
  var children = props.children,
      tooltipSize = props.tooltipSize,
      tooltipTitle = props.tooltipTitle,
      tooltipContent = props.tooltipContent,
      typographySize = props.typographySize,
      typographyType = props.typographyType,
      colorConfig = props.colorConfig,
      bodyConfig = props.bodyConfig,
      iconConfig = props.iconConfig;
  var childArray = children ? checkForNode(children).childArray : [];
  var textWithIcon = children ? checkForNode(children).textWithIcon : '';
  return /*#__PURE__*/React.createElement(Fragment, null, /*#__PURE__*/React.createElement(StyledSpan, {
    tabIndex: -1
  }, childArray, /*#__PURE__*/React.createElement(ChildWrapper, null, textWithIcon, /*#__PURE__*/React.createElement(InlineWrapper, {
    type: typographyType,
    size: typographySize
  }, /*#__PURE__*/React.createElement(Tooltip, {
    focusState: true,
    hoverState: true,
    activeState: true,
    iconConfig: iconConfig,
    bodyConfig: bodyConfig,
    colorConfig: colorConfig,
    typescale: "VDS",
    dialogPadding: calculateRem(12, 0, 12, 12),
    size: tooltipSize,
    title: tooltipTitle
  }, /*#__PURE__*/React.createElement(TooltipContent, null, tooltipContent))))));
}

function _calcTypographyComponent(props) {
  var Body = props.Body,
      Subtitle = props.Subtitle,
      Micro = props.Micro,
      Title = props.Title,
      typographyType = props.typographyType;
  var comp = Body;
  if (typographyType === 'title') comp = Title;
  if (typographyType === 'subtitle') comp = Subtitle;
  if (typographyType === 'micro') comp = Micro;
  return comp;
}

var TrailingTooltip = function TrailingTooltip(props) {
  var typographyPrimitive = props.typographyPrimitive,
      viewport = props.viewport,
      typographySize = props.typographySize,
      colorConfig = props.colorConfig,
      bold = props.bold,
      typographyColor = props.typographyColor;

  var TypographyComponent = _calcTypographyComponent(props);

  return /*#__PURE__*/React.createElement(TypographyComponent, {
    primitive: typographyPrimitive,
    viewport: viewport,
    size: typographySize,
    color: typographyColor,
    bold: bold,
    tabIndex: -1
  }, _renderWithIcon(props));
};

TrailingTooltip.defaultProps = defaultProps;
TrailingTooltip.propTypes = propTypes;
export default TrailingTooltip;