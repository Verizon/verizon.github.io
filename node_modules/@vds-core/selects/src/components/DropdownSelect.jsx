import React from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import { calculateRem } from '@uie/javascript-style-helpers';
import Icon, { IconData } from '@vds-core/icons';
import {
  BodyConfig,
  MicroConfig,
  TypographyConfig,
  Micro,
  Body,
} from '@vds-core/typography';
import { withVDSManager } from '@vds-core/utilities';

import { colors, calculateSpacing } from '@vds-core/theme';
import cuid from 'cuid';

const propTypes = {
  /**
   * disables the Dropdown
   */
  disabled: PropTypes.bool,
  /**
   * @deprecated
   * Locks the input from user interaction.
   */
  locked: PropTypes.bool,
  /**
   * Notify the user if there is an error
   */
  error: PropTypes.bool,
  /**
   * Locks the input from user interaction.
   */
  readOnly: PropTypes.bool,
  /**
   * Items for the Dropdown List.
   */
  children: PropTypes.node,
  /**
   * Message displayed when there is an error
   */
  errorText: PropTypes.string,
  /**
   * This is a label for the select input
   */
  label: PropTypes.string,
  /**
   * This is the width of the select box. Any string can be passed such as 100% or a pixel value.
   */
  width: PropTypes.string,
  /**
   * @deprecated
   * Will render borderless if set to true.
   */
  borderless: PropTypes.bool,
  /**
   * @ignore defines height of the select field
   */
  height: PropTypes.string,
  /**
   * @ignore defines padding inside of the select field
   */
  selectPadding: PropTypes.string,
  /**
   * @ignore defines the space between the label and the dropdown input
   */
  labelMarginBottom: PropTypes.string,
  /**
   * @ignore defines whether text trancates with ellipsis or not
   */
  overflowEllipsis: PropTypes.bool,
  /**
   * @ignore defines the space between the select and the error text below
   */
  errorLabelSpacing: PropTypes.string,
  /**
   * @ignore adds the ability to use borders when in ready only state (default is borderless)
   */
  readOnlyBorders: PropTypes.bool,
  /**
   * @ignore adds hover state to select field
   */
  hoverState: PropTypes.bool,
  /**
   * @ignore adds or removes focus states
   */
  focusState: PropTypes.bool,
  /**
   * @ignore adds max-width to select field
   */
  maxWidth: PropTypes.string,
  /**
   * @ignore adds min-width to select field
   */
  minWidth: PropTypes.string,
  /**
   * @ignore used to define colors throught component
   */
  color: PropTypes.object,
  /**
   * @ignore passes through typescale via string if there's more than one option [example 'VDS' instead of 'MVP']
   */
  typescale: PropTypes.string,
  /**
   * @ignore config for passing though typography
   */
  bodyConfig: PropTypes.object,
  /**
   * If false, puts a string of 'Optional' next to the label
   */
  required: PropTypes.bool,
  /**
   * @ignore passes through data for Icons
   */
  iconConfig: PropTypes.object,
  /**
   * Allows a string to be provided for analytics.
   */
  'data-analyticstrack': PropTypes.string,
  /**
   * Allows a string to be provided for analytics.
   */
  'data-track': PropTypes.string,
  /**
   * Allows a string to be provided for click stream.
   */
  'data-clickstream': PropTypes.string,
  /**
   * Allows a unique ID to be passed to the component.
   */
  id: PropTypes.string,
  /**
   * @ignore If passed, the Tooltip will render
   */
  Tooltip: PropTypes.func,
  /**
   * @ignore If passed, new Body component will render
   */
  Body: PropTypes.func,
  /**
   * @ignore If passed, new Micro component will render
   */
  Micro: PropTypes.func,
};

const defaultProps = {
  disabled: false,
  locked: false,
  error: false,
  readOnly: false,
  width: '100%',
  borderless: false,
  label: '',
  height: calculateRem(42),
  selectPadding: calculateRem(12, 40, 12, 16),
  labelMarginBottom: calculateRem(1),
  overflowEllipsis: false,
  errorLabelSpacing: calculateRem(4),
  readOnlyBorders: false,
  hoverState: false,
  focusState: false,
  maxWidth: undefined,
  minWidth: undefined,
  required: true,
  color: colors,
  typescale: TypographyConfig.getTypescale(),
  bodyConfig: BodyConfig,
  iconConfig: IconData,
  Body: Body,
  Micro: Micro,
};

/* Line height of p tag is 15px but because it contains a tooltip it maintains the 16px line height.*/
const LabelWrapper = styled.label`
  display: inline-flex;
  margin-bottom: ${({ labelMarginBottom }) => labelMarginBottom};
  width: ${({ helperText, helperTextPlacement }) =>
    helperText && helperTextPlacement === 'right' ? '50%' : '100%'};
  > * {
    white-space: ${({ overflowEllipsis }) =>
      overflowEllipsis ? 'normal' : 'nowrap'};
    text-overflow: ${({ overflowEllipsis }) =>
      overflowEllipsis ? null : 'ellipsis'};
    overflow: ${({ overflowEllipsis }) => (overflowEllipsis ? null : 'hidden')};
  }

  p {
    line-height: ${({ hasTooltip }) =>
      hasTooltip ? calculateRem(15) : calculateRem(16)};
  }

  ${({ focusState }) =>
    focusState &&
    `
    &:focus,
    &:active {
      outline: none;
    }
  `};
`;

const ErrorTextWrapper = styled.div`
  margin-top: ${({ errorLabelSpacing }) => errorLabelSpacing};
`;

const SelectContainer = styled.div`
  position: relative;
  display: inline-flex;
  align-items: center;
  box-sizing: border-box;
  height: ${({ height }) => height};
  width: 100%;
  vertical-align: top;
  margin: 0;
  background-color: ${({ color }) => color.white};
  color: ${({ color, disabled, readOnly }) =>
    disabled && !readOnly ? color.coolGray3 : color.primary};
  border-radius: 0;
  border-top: ${calculateRem(1)} solid ${({ color }) => color.coolGray3};
  border-right: ${calculateRem(1)} solid ${({ color }) => color.coolGray3};
  border-left: ${calculateRem(1)} solid ${({ color }) => color.coolGray3};
  border-bottom: ${calculateRem(1)} solid
    ${({ color, disabled }) => (disabled ? color.coolGray3 : color.black)};

  ${({ error, color }) =>
    error &&
    `border-left: ${calculateRem(1)} solid ${color.error};
    border-top: ${calculateRem(1)} solid ${color.error};
    border-right: ${calculateRem(1)} solid ${color.error};
    border-bottom: ${calculateRem(4)} solid ${color.error};
  `};

  ${({ disabled, color, readOnly }) =>
    disabled &&
    !readOnly &&
    `color: ${color.coolGray3};
     border-color: ${color.coolGray3};
  `};

  ${({ readOnly, color }) =>
    readOnly &&
    `border-color: ${color.coolGray3};
  `};

  ${({ locked, readOnly, readOnlyBorders, color }) =>
    (locked || readOnly) &&
    `border: ${
      readOnlyBorders ? `${calculateRem(1)} solid ${color.coolGray3}` : 'none'
    };
  `};

  ${({ borderless }) =>
    borderless &&
    `border: none;
  `};

  ${({ hoverState, readOnly, disabled, error, color }) =>
    hoverState &&
    `
    &:hover {
      border-left: ${calculateRem(1)} solid ${
      readOnly || disabled ? color.coolGray3 : color.black
    };
      border-top: ${calculateRem(1)} solid ${
      readOnly || disabled ? color.coolGray3 : color.black
    };
      border-right: ${calculateRem(1)} solid ${
      readOnly || disabled ? color.coolGray3 : color.black
    };
      }
`};

  ${({ focused, color, error, readOnly, disabled, locked }) =>
    focused &&
    !readOnly &&
    !locked &&
    !disabled &&
    `
    outline: none;
    border-left: ${calculateRem(1)} solid ${color.black};
    border-top: ${calculateRem(1)} solid ${color.black};
    border-right: ${calculateRem(1)} solid ${color.black};
    border-bottom: ${error ? calculateRem(4) : calculateRem(1)}
      solid ${error ? color.error : color.black};

  `};
`;

const SelectEl = styled.select`
  border: none;
  background: transparent;
  width: 100%;
  display: inline-flex;
  appearance: none;
  &::-ms-expand {
    display: none;
  }

  :-moz-focusring {
    color: transparent;
    text-shadow: 0 0 0 #000;
  }
  outline: none;
  color: ${({ color, disabled, readOnly }) =>
    disabled && !readOnly ? color.coolGray3 : color.primary};
  line-height: ${({ body }) => calculateRem(body.lineHeight)};
  font-size: ${({ body }) => calculateRem(body.fontSize)};
  font-family: ${({ body }) => body.fontFamily};
  letter-spacing: ${({ body }) => calculateRem(body.letterSpacing)};
  padding: ${({ selectPadding, inlineLabel, error }) =>
    inlineLabel
      ? error
        ? calculateRem(12, 44, 9, 0)
        : calculateRem(12, 44, 12, 0)
      : selectPadding};
  padding-left: ${({ readOnly, locked, readOnlyBorders }) =>
    (readOnly || locked) && !readOnlyBorders ? 0 : null};
  padding-bottom: ${({ error }) =>
    error ? calculateRem(9) : calculateRem(12)};
`;

const ComponentContainer = styled.div`
  display: flex;
  flex-direction: ${({ helperTextPlacement }) =>
    helperTextPlacement === 'right' ? 'row' : 'column'};
  width: ${({ width }) => width};
  max-width: ${({ maxWidth }) => maxWidth};
  min-width: ${({ minWidth }) => minWidth};
`;

const StyledContainer = styled.div`
  display: flex;
  flex: 1 1 auto;
  flex-direction: column;
  width: ${({ helperText, helperTextPlacement }) =>
    helperText && helperTextPlacement === 'right' ? '50%' : '100%'};
  position: relative;
  width: ${({ width }) => width};
  input[type='number'] {
    -moz-appearance: textfield; /* Firefox */
  }
`;

const OptionalLabel = styled.span`
  margin: 0;
  outline: none;
  ${({ required, disabled, color }) =>
    !required &&
    `:after {
        color: ${disabled ? color.coolGray3 : color.coolGray6};
        content: ' Optional';
        display: inline;
      }`};
`;

const IconContainer = styled.span`
  position: absolute;
  z-index: 1;
  margin-left: ${calculateRem(12)};
  right: ${({ typescale }) =>
    typescale === 'VDS' ? calculateRem(12) : calculateRem(16)};
  top: ${({ typescale }) =>
    typescale === 'VDS' ? calculateRem(12) : calculateRem(13)};
  pointer-events: none;
  ${({ disabled, color }) =>
    disabled &&
    `
    color: ${color.grayLight};
    border-color: ${color.grayLight};
  `};
`;

const InlineLabel = styled.label`
  white-space: nowrap;
  padding: ${({ error }) =>
    error ? calculateRem(12, 4, 9, 12) : calculateRem(12, 4, 12, 12)};
  &:focus {
    outline: none;
  }
`;

const FlexedRowContainer = styled.span`
  display: flex;
  flex: 1 1 auto;
  flex-direction: row;
  position: relative;
`;

const FlexedColContainer = styled.span`
  display: flex;
  flex: 1 1 auto;
  flex-direction: column;
  position: relative;
  width: ${({ helperText, helperTextPlacement }) =>
    helperText && helperTextPlacement === 'right' ? '50%' : '100%'};
`;

const HelperText = styled.div`
  display: flex;
  flex: 1 1 auto;
  width: 100%;
  box-sizing: border-box;
  ${({ helperTextPlacement, label }) =>
    helperTextPlacement === 'right' &&
    `
    position: relative;
    width: 50%;
    padding-top: 0px;
    padding-left: ${calculateSpacing('3X')};
  `};
  ${({ helperTextPlacement }) =>
    helperTextPlacement === 'bottom' &&
    `
    padding-top: ${calculateSpacing('2X')};
  `};
`;

const AlignTooltip = styled.span`
  display: inline-flex;
  vertical-align: text-bottom;
`;

class Select extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      iconFocused: true,
      selectFocus: false,
      selectedValue: undefined /* selectedValue is used to give the aria label 'selected' */,
    };
  }

  componentDidMount() {
    const { children } = this.props;
    /* Check if an option has been passed a selected prop, if so set selected state to that item */
    if (children && children.length > 1) {
      children.map(child => {
        if (
          child &&
          child.props &&
          child.props.children &&
          child.props.selected
        ) {
          this.setState({ selectedValue: child.props.children });
        }
      });
      /* If there was no selected value passed, then default the selectedValue to the first child */
      if (
        !this.state.selectedValue &&
        children[0] &&
        children[0].props &&
        children[0].props.children
      ) {
        this.setState({ selectedValue: children[0].props.children });
      }
      /* if there is only one child passed */
    } else if (children && children.props && children.props.children) {
      this.setState({ selectedValue: children.props.children });
    }
  }
  _hideIcon = () => {
    this.setState({ iconFocused: false, selectFocus: true });
  };

  _showIcon = () => {
    this.setState({ iconFocused: true, selectFocus: false });
  };

  _renderHelperText = () => {
    const {
      inlineLabel,
      helperTextPlacement,
      color,
      bodyConfig,
      disabled,
      typescale,
      helperText,
    } = this.props;
    return (
      <HelperText
        inlineLabel={inlineLabel}
        helperTextPlacement={helperTextPlacement}
        aria-hidden="true"
      >
        <Body
          config={bodyConfig}
          color={disabled ? color.coolGray3 : color.coolGray6}
          typescale={typescale}
        >
          {helperText}
        </Body>
      </HelperText>
    );
  };

  renderIcon = ({
    disabled,
    error,
    readOnly,
    color,
    typescale,
    height,
    iconConfig,
    inlineLabel,
  }) => {
    return (
      <IconContainer
        tabIndex={-1}
        height={height}
        error={error}
        disabled={disabled}
        color={color}
        aria-hidden={true}
        inlineLabel={inlineLabel}
        typescale={typescale}
      >
        {!readOnly && (
          <Icon
            tabIndex={-1}
            data={iconConfig}
            size={typescale === 'VDS' ? 'medium' : 'small'}
            name={
              error && this.state.iconFocused && typescale === 'VDS'
                ? 'error'
                : 'caret-down'
            }
            color={disabled ? color.coolGray3 : color.black}
            aria-hidden={true}
          />
        )}
      </IconContainer>
    );
  };

  _labelOnClick = e => {
    if (e.target.id !== 'labelId') {
      e.preventDefault();
    }
  };

  _onChange = e => {
    this.props.onChange && this.props.onChange(e);
    this.setState({ selectedValue: e.target.value });
  };

  _renderChildren = () => {
    const { children } = this.props;
    if (!children) return null;
    return React.Children.map(children, (child, index) => {
      return React.cloneElement(child, {
        'aria-label': `${child.props.children} item ${index + 1} of ${
          children.length > 1 ? children.length : 1
        } ${
          child.props.children === this.state.selectedValue ? 'selected' : ''
        }`,
      });
    });
  };

  render() {
    const {
      disabled,
      locked,
      error,
      readOnly,
      label,
      errorText,
      width,
      children,
      borderless,
      bodyConfig,
      typescale,
      color,
      required,
      labelMarginBottom,
      overflowEllipsis,
      errorLabelSpacing,
      readOnlyBorders,
      selectPadding,
      height,
      hoverState,
      focusState,
      maxWidth,
      minWidth,
      id,
      inlineLabel,
      Tooltip,
      tooltipContent,
      tooltipTitle,
      helperText,
      helperTextPlacement,
      Body,
      Micro,
      ariaLabel,
      className,
    } = this.props;

    const unique_id = cuid();

    let fontSize, LabelType;
    if (typescale === 'VDS') {
      fontSize = 'large';
      LabelType = Body;
    } else {
      fontSize = 'medium';
      LabelType = Micro;
    }
    let labelId = 'labelId';

    const body = bodyConfig.getStyles(typescale, 'desktop', fontSize);

    function _onKeyDown(e) {
      if (e.type !== 'click' && e.detail === 0) e.target.focus();
    }

    let accessLabel = label
      ? !required
        ? label + ' Optional'
        : label
      : ariaLabel;

    error &&
      !errorText &&
      console.error('Error Text for DropdownSelect MUST be provided');

    return (
      <ComponentContainer
        width={width}
        maxWidth={maxWidth}
        minWidth={minWidth}
        helperTextPlacement={helperTextPlacement}
        className={className}
      >
        <StyledContainer
          id={id}
          helperTextPlacement={helperTextPlacement}
          helperText={helperText}
        >
          {label && !inlineLabel && (
            <LabelWrapper
              id={labelId}
              width={width}
              onKeyDown={_onKeyDown}
              focusState={focusState}
              overflowEllipsis={overflowEllipsis}
              aria-label={label}
              htmlFor={unique_id}
              labelMarginBottom={labelMarginBottom}
              helperText={helperText}
              helperTextPlacement={helperTextPlacement}
              onClick={this._labelOnClick}
              hasTooltip={tooltipTitle || tooltipContent}
            >
              <LabelType
                id={labelId}
                config={typescale === 'VDS' ? bodyConfig : MicroConfig}
                primitive={'p'}
                typescale={typescale}
                color={
                  disabled
                    ? color.coolGray3
                    : typescale === 'VDS'
                    ? color.black
                    : color.coolGray6
                }
              >
                {label}
                <OptionalLabel
                  id={labelId}
                  disabled={disabled}
                  aria-label={label}
                  color={color}
                  required={required}
                />
                {(tooltipTitle || tooltipContent) && label && (
                  <AlignTooltip>
                    <Tooltip
                      size="small"
                      disabled={disabled}
                      title={tooltipTitle}
                    >
                      {tooltipContent}
                    </Tooltip>
                  </AlignTooltip>
                )}
              </LabelType>
            </LabelWrapper>
          )}
          <FlexedRowContainer>
            <FlexedColContainer
              helperText={helperText}
              helperTextPlacement={helperTextPlacement}
            >
              <SelectContainer
                color={color}
                selectPadding={selectPadding}
                readOnlyBorders={readOnlyBorders}
                height={height}
                typescale={typescale}
                hoverState={hoverState}
                bodyConfig={bodyConfig}
                body={body}
                borderless={borderless}
                disabled={disabled}
                readOnly={locked || readOnly}
                error={error}
                width={width}
                focused={this.state.selectFocus}
              >
                {inlineLabel && label && (
                  <InlineLabel error={error} tabIndex={-1} htmlFor={unique_id}>
                    <Body
                      typescale={typescale}
                      size="large"
                      config={bodyConfig}
                      bold
                      color={disabled ? color.coolGray3 : color.black}
                    >
                      {label}
                    </Body>
                  </InlineLabel>
                )}
                <SelectEl
                  aria-label={
                    helperText ? `${accessLabel} ${helperText}` : accessLabel
                  }
                  {...this.props}
                  readOnlyBorders={readOnlyBorders}
                  disabled={disabled || readOnly || locked}
                  typescale={typescale}
                  bodyConfig={bodyConfig}
                  id={unique_id}
                  body={body}
                  tabIndex={0}
                  onKeyDown={_onKeyDown}
                  onFocus={this._hideIcon}
                  onBlur={this._showIcon}
                  onChange={this._onChange}
                >
                  {this._renderChildren()}
                </SelectEl>
                {this.renderIcon(this.props)}
              </SelectContainer>
              {error && errorText && (
                <ErrorTextWrapper
                  errorLabelSpacing={errorLabelSpacing}
                  width={width}
                >
                  <LabelType
                    config={typescale === 'VDS' ? bodyConfig : MicroConfig}
                    typescale={typescale}
                  >
                    {errorText}
                  </LabelType>
                </ErrorTextWrapper>
              )}
            </FlexedColContainer>
            {helperText &&
              helperTextPlacement === 'right' &&
              this._renderHelperText()}
          </FlexedRowContainer>
          {helperText &&
            helperTextPlacement === 'bottom' &&
            this._renderHelperText()}
        </StyledContainer>
      </ComponentContainer>
    );
  }
}

Select.propTypes = propTypes;
Select.defaultProps = defaultProps;

export default withVDSManager(Select);
