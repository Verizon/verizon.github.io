import React, { Component } from 'react';
import PropTypes from 'prop-types';
import styled, { keyframes } from 'styled-components';
import { calculateRem } from '@uie/javascript-style-helpers';
import {
  BodyConfig,
  TitleConfig,
  TypographyConfig,
} from '@vds-core/typography';
import { colors } from '@vds-core/theme';
import UNSAFE_SetEnvRef from '@uie/set-env-ref';
/*
fontWeightBold represents the font weight found in 
typography used when the component is bolded. Font weight is
not exported by typography configs due to the fact that 
typography components may have multiple font weight options
*/
const fontWeightBold = 'bold';

function _calculateListItemHeight(size) {
  if (size === 'small') {
    return calculateRem(42);
  } else return calculateRem(56);
}

function _calculateListItemPadding(size, viewport) {
  if (size === 'small' && viewport === 'mobile') {
    return calculateRem(14, 14, 13.6, 14);
  } else if (size === 'small' && viewport !== 'mobile') {
    return calculateRem(13, 14, 12.2, 14);
  } else if (size !== 'small' && viewport === 'mobile') {
    return calculateRem(16, 12, 16, 12);
  } else {
    return calculateRem(13, 12, 12.6, 12);
  }
}

const propTypes = {
  /**
   * @ignore
   */
  color: PropTypes.object,
  /**
   * @ignore
   * config for passing though title typography
   */
  titleConfig: PropTypes.object,
  /**
   * @ignore
   * config for passing though bible typography
   */
  bodyConfig: PropTypes.object,
  /**
   * @ignore
   * passes through typescale via sting if there's more than one option [example 'VDS' instead of 'MVP']
   */
  typescale: PropTypes.string,
  /**
   * @ignore
   * function that calculates the height of the drop down list item
   */
  calculateListItemHeight: PropTypes.func,
  /**
   * @ignore
   * function that calculates the padding inside of each list item
   */
  calculateListItemPadding: PropTypes.func,
  /**
   * @ignore
   * boolean that, if true, changes the hover states
   */
  hoverState: PropTypes.bool,
  /**
   * @ignore
   * boolean that, if true, changes the focus states
   */
  focusState: PropTypes.bool,
  /**
   * @ignore
   * togggles list when executed
   */
  toggleList: PropTypes.func,
};

const defaultProps = {
  color: colors,
  titleConfig: TitleConfig,
  bodyConfig: BodyConfig,
  typescale: TypographyConfig.getTypescale(),

  calculateListItemHeight: _calculateListItemHeight,
  calculateListItemPadding: _calculateListItemPadding,
  hoverState: false,
  focusState: false,
};

const slideDown = keyframes`
  0% {
    opacity: 0;
    transform: translateY(-10px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
`;

const List = styled.ul`
  z-index: 2;
  position: absolute;
  left: 0;
  top: 100%;
  margin: 0;
  padding: 0;
  width: ${({ width }) => width};

  .slide-down[data-menu-list] {
  }

  > [data-menu] {
    display: block;
  }

  &[data-menu-list] {
    animation: ${slideDown} 0.2s ease;
    background: ${({ color }) => color.white};
    padding-bottom: 0;
    padding-top: 0;

    transition: border 400ms, height 350ms;
  }

  > [data-menu-item],
  li {
    display: flex;
    align-items: center;
    background: none;
    border-left: 1px solid ${({ color }) => color.coolGray3};
    border-right: 1px solid ${({ color }) => color.coolGray3};
    border-bottom: 1px solid ${({ color }) => color.coolGray3};
    box-sizing: border-box;
    min-height: ${({ calculateListItemHeight, size }) =>
      calculateListItemHeight(size)};
  }
  > [data-menu-item],
  li {
    overflow-wrap: anywhere;
    width: 100%;
    display: flex;
    align-items: center;
    color: ${({ color }) => color.coolGray6};
    cursor: pointer;
    text-align: left;
    text-decoration: none;
    margin-top: ${calculateRem(-1)};

    padding: ${({ calculateListItemPadding, size, viewport }) =>
      calculateListItemPadding(size, viewport)};

    font-weight: ${fontWeightBold};
    font-family: ${({ body }) => body.fontFamily};
    font-size: ${({ body }) => calculateRem(body.fontSize)};
    line-height: ${({ body }) => calculateRem(body.lineHeight)};

    &:hover {
      color: ${({ color }) => color.black};
    }

    &:focus {
      outline: none;
      color: ${({ focusState, color }) => (focusState ? null : color.black)};
      transition: color 300ms;
    }

    ${({ hoverState, color }) =>
      hoverState &&
      `
      &:hover {
        color: ${color.black};
        transition: color 300ms;
      }
    `}

    ${({ focusState, color }) =>
      focusState &&
      `
      &:focus {
        outline: ${calculateRem(1)} dashed ${color.black};
        outline-offset: -${calculateRem(8)};
      }

      &:hover,
      &:active {
        outline: none;
        outline-offset: 0;
      }

    `}    

    &:first-of-type {
      margin-top: 0;
    }
  }

  > [data-menu-item][data-selected] {
    background: transparent;
    color: ${({ color }) => color.black};
    transition: color 300ms;
  }
`;

/**
 * @ignore
 */
class DropdownList extends Component {
  constructor(props) {
    super(props);
  }

  componentDidMount = () => {
    let topOfList = this.props.itemId + 'option=0';
    this.props.keyboardFocused && document.getElementById(topOfList).focus();
  };

  _onKeyDown = e => {
    let key = e.keyCode;
    let shift = e.shiftKey;
    let tab = key === 9;
    let currentId = e.target.id;
    let index = parseInt(currentId.split('=')[1]); //strips index from option id
    let itemPreface = this.props.itemId + 'option=';
    let firstOption = itemPreface + '0';
    let lastOption = itemPreface + (this.props.children.length - 1);
    let nextOption = itemPreface + (index + 1);
    let previousOption = itemPreface + (index - 1);

    e.preventDefault();
    if (shift && tab) key = 37; //if shift + tab, go backward

    switch (key) {
      case 37: //shift + tab, up or right moves position backwards in list
      case 38:
        if (currentId === firstOption) {
          document.getElementById(lastOption).focus();
        } else {
          document.getElementById(previousOption).focus();
        }
        break;
      case 9:
      case 39:
      case 40: //tab, down or left advances position in list
        if (currentId === lastOption) {
          document.getElementById(firstOption).focus();
        } else {
          document.getElementById(nextOption).focus();
        }
        break;
      case 27: //esc closes list
        this.props.toggleList();
        this.props.trigger.focus();
        break;
    }
  };

  _renderChildren = (children, itemId) => {
    return React.Children.map(children, (child, i) => {
      let id = this.props.itemId + 'option=' + i;
      let el = React.cloneElement(child, {
        id: id,
        selectionCallback: this.props.onSelect,
      });
      return el;
    });
  };

  render() {
    const {
      color,
      size,
      viewport,
      calculateListItemHeight,
      calculateListItemPadding,
      titleConfig,
      bodyConfig,
      typescale,
      hoverState,
      focusState,
      children,
      width,
    } = this.props;

    let fontScale;
    if (size === 'small' && typescale !== 'VDS') {
      fontScale = 'desktop';
    } else {
      fontScale = viewport === 'mobile' ? 'mobile' : 'desktop';
    }

    let fontSize;
    if (typescale === 'VDS') {
      fontSize = size === 'small' ? 'small' : 'large';
    } else {
      if (size === 'small') {
        fontSize = viewport === 'mobile' ? 'small' : 'medium';
      } else {
        fontSize = 'large';
      }
    }

    let typeConfig;
    if (size !== 'small' || typescale === 'VDS') {
      typeConfig = titleConfig;
    } else {
      typeConfig = bodyConfig;
    }

    const body = typeConfig.getStyles(typescale, fontScale, fontSize);

    return (
      <List
        width={width}
        onKeyDown={this._onKeyDown}
        role="listbox"
        id="dropdown-list"
        body={body}
        size={size}
        focusState={focusState}
        hoverState={hoverState}
        viewport={viewport}
        titleConfig={titleConfig}
        bodyConfig={bodyConfig}
        typescale={typescale}
        calculateListItemHeight={calculateListItemHeight}
        calculateListItemPadding={calculateListItemPadding}
        color={color}
        data-menu-list
        {...this.props}
      >
        {this._renderChildren(children)}
      </List>
    );
  }
}
DropdownList.defaultProps = defaultProps;
DropdownList.propTypes = propTypes;

export default DropdownList;
