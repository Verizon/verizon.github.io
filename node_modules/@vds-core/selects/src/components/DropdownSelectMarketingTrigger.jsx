import React, { Component } from 'react';
import PropTypes from 'prop-types';
import UNSAFE_SetEnvRef from '@uie/set-env-ref';
import styled from 'styled-components';
import { calculateRem } from '@uie/javascript-style-helpers';
import {
  BodyConfig,
  TitleConfig,
  TypographyConfig,
} from '@vds-core/typography';
import { colors } from '@vds-core/theme';

/*
fontWeightBold represents the font weight found in 
typography used when the component is bolded. Font weight is
not exported by typography configs due to the fact that 
typography components may have multiple font weight options
*/
const fontWeightBold = 'bold';

const propTypes = {
  /**
   * @ignore
   * ref for component
   */
  setTriggerRef: PropTypes.func,
  /**
   * @ignore
   * config for colors
   */
  color: PropTypes.object,
  /**
   * @ignore
   * boolean that, if true, changes the hover states
   */
  size: PropTypes.oneOf(['large', 'normal', 'medium', 'small']),
  /**
   * @ignore
   * boolean that, if true, changes the hover states
   */
  viewport: PropTypes.oneOf(['mobile', 'tablet', 'desktop']),
  /**
   * @ignore
   * prop that changes the padding between the text and the bottom line
   */
  triggerPaddingBottom: PropTypes.string,
  /**
   * @ignore
   * string that changes which typescale to use for typography
   */
  typescale: PropTypes.string,
  /**
   * @ignore
   * config for body typography
   */
  bodyConfig: PropTypes.object,
  /**
   * @ignore
   * config for title typography
   */
  titleConfig: PropTypes.object,
  /**
   * @ignore
   * boolean that, if true, adds an additional hit area
   */
  hitArea: PropTypes.bool,
  /**
   * @ignore
   * boolean that, if true, changes the focus states
   */
  focusState: PropTypes.bool,
};

const defaultProps = {
  setTriggerRef: () => {},
  size: 'large',
  viewport: 'desktop',
  color: colors,
  hitArea: false,
  focusState: false,
  triggerPaddingBottom: calculateRem(2),
  typescale: TypographyConfig.getTypescale(),
  bodyConfig: BodyConfig,
  titleConfig: TitleConfig,
};

const Trigger = styled.button`
  display: flex;
  position: relative;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  background: transparent;
  border-bottom: ${({ error, disabled, color }) => {
    let borderColor = error
      ? color.error
      : disabled
      ? color.coolGray3
      : color.black;
    let borderHeight = calculateRem(error ? 4 : 1);
    return `${borderHeight} solid ${borderColor}`;
  }};
  border-top: 0;
  border-right: 0;
  border-left: 0;
  padding: 0;
  margin: 0;
  padding-bottom: ${({ triggerPaddingBottom }) => triggerPaddingBottom};
  color: ${props =>
    props.disabled
      ? props.color.coolGray3
      : props.selected
      ? props.color.black
      : props.color.coolGray6};
  cursor: ${({ disabled }) => (disabled ? 'default' : 'pointer')};
  position: relative;
  transition: border 300ms;
  transition: color 300ms;
  width: ${({ width }) => width};
  overflow: ${({ hitArea }) => (hitArea ? 'visible' : 'hidden')};
  text-overflow: ellipsis;
  z-index: 1;
  white-space: nowrap;
  &.focus-visible {
    background: white;
    color: ${({ color }) => color.black};
    transition: color 300ms;
  }

  ${({ focusState, color }) =>
    focusState &&
    `
  &:focus {
    outline: ${calculateRem(1)} dashed ${color.black};
    outline-offset: ${calculateRem(2)};
    color: ${color.black};
  }

  &:focus-visible {
    outline: ${calculateRem(1)} dashed ${color.black};
    outline-offset: ${calculateRem(2)};
    color: ${color.black};
  }

  :-moz-focusring {
    color: transparent;
    text-shadow: 0 0 0 #000;
  }

`}

  &:hover,
  &:active {
    outline: none;
    outline-offset: 0;
  }

  font-weight: ${fontWeightBold};
  font-family: ${({ body }) => body.fontFamily};
  font-size: ${({ body }) => calculateRem(body.fontSize)};
  line-height: ${({ body }) => calculateRem(body.lineHeight)};

  ${({ disabled, color }) =>
    !disabled &&
    `
      &:hover {
        transition: color 300ms;
        color: ${color.black};
      }
  `}

  * {
    outline: none;
    outline-offset: 0;
  }
`;

/**
 * @ignore
 */
class DropdownTrigger extends Component {
  componentDidMount = () => {
    this.props.setTriggerRef(this.triggerElem);
  };

  refKey = UNSAFE_SetEnvRef();

  render() {
    const {
      hitArea,
      color,
      focusState,
      size,
      typescale,
      viewport,
      titleConfig,
      bodyConfig,
    } = this.props;

    let fontScale;
    if (size === 'small' && typescale !== 'VDS') {
      fontScale = 'desktop';
    } else {
      fontScale = viewport === 'mobile' ? 'mobile' : 'desktop';
    }

    let fontSize;
    if (typescale === 'VDS') {
      fontSize = size === 'small' ? 'small' : 'large';
    } else {
      if (size === 'small') {
        fontSize = viewport === 'mobile' ? 'small' : 'medium';
      } else {
        fontSize = 'large';
      }
    }

    let typeConfig;
    if (size !== 'small' || typescale === 'VDS') {
      typeConfig = titleConfig;
    } else {
      typeConfig = bodyConfig;
    }

    const body = typeConfig.getStyles(typescale, fontScale, fontSize);
    return (
      <Trigger
        body={body}
        bodyConfig={bodyConfig}
        titleConfig={titleConfig}
        typescale={typescale}
        viewport={viewport}
        body={body}
        size={size}
        focusState={focusState}
        hitArea={hitArea}
        role="listbox"
        aria-owns="dropdown-list"
        {...this.props}
        {...{ [this.refKey]: elem => (this.triggerElem = elem) }}
      />
    );
  }
}

DropdownTrigger.defaultProps = defaultProps;
DropdownTrigger.propTypes = propTypes;

export default DropdownTrigger;
