import _extends from "@babel/runtime/helpers/extends";
import _taggedTemplateLiteral from "@babel/runtime/helpers/taggedTemplateLiteral";

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  background-color: ", ";\n  display: inline-block;\n  height: ", ";\n  width: ", ";\n  min-height: ", ";\n  min-width: ", ";\n  ", ";\n  ", "\n  ", "\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import IconData from './data.json';
import { calculateRem } from '@uie/javascript-style-helpers';
import { verizonTheme as colors } from '@vds-core/theme';
var propTypes = {
  /**
   * @ignore
   */
  ariaLabel: PropTypes.string,

  /**
   * Name of icon. Identifies which icon to render.
   */
  name: PropTypes.string.isRequired,

  /**
   * Size of the icon.
   */
  size: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * @deprecated
   */
  lineColor: PropTypes.string,
  //DEPRECATED

  /**
   * Color of the icon.
   */
  color: PropTypes.string,

  /**
   * @deprecated
   * Background color of the icon.
   */
  backgroundColor: PropTypes.string,

  /**
   * @deprecated
   * Optional React Style Object that will be passed on to the SVG Tag.
   */
  style: PropTypes.object,

  /**
   * The tabIndex of the icon.
   */
  tabIndex: PropTypes.number,

  /**
   * Boolean to determine if Icon is inverted.
   */
  inverted: PropTypes.bool,

  /**
   * @ignore
   */
  data: PropTypes.object,
  // passes through icon data object

  /**
   * @ignore
   */
  medium: PropTypes.bool,
  // determines the stoke width of the icon path, if true, stoke with is 2px, otherwise it's 1px.

  /**
   * @ignore
   * Boolean to determine if Icon is focused
   */
  focused: PropTypes.bool,

  /**
   * @ignore
   * Boolean to determine if Icon should receive focus state
   */
  focusState: PropTypes.bool,

  /**
   * @ignore
   * Boolean to determine if Icon should receive focus state
   */
  focusRadius: PropTypes.string,

  /**
   * Allows a unique ID to be passed to the component.
   */
  id: PropTypes.string,

  /**
   * Hides content from assistive technology when set to true
   */
  ariaHidden: PropTypes.bool
};
var defaultProps = {
  size: 'extraSmall',
  color: 'black',
  backgroundColor: 'transparent',
  style: undefined,
  lineColor: undefined,
  //DEPRECATED
  tabIndex: 0,
  inverted: false,
  // props created for 1.0
  data: IconData,
  medium: false,
  focused: false,
  focusState: false,
  focusRadius: '50%'
};
var StyledSVG = /*#__PURE__*/styled.svg.withConfig({
  displayName: "StyledSVG",
  componentId: "oulxgz-0"
})(_templateObject(), function (props) {
  return props.backgroundColor;
}, function (_ref) {
  var iconHeight = _ref.iconHeight;
  return calculateRem(iconHeight);
}, function (_ref2) {
  var iconWidth = _ref2.iconWidth;
  return calculateRem(iconWidth);
}, function (_ref3) {
  var iconHeight = _ref3.iconHeight;
  return calculateRem(iconHeight);
}, function (_ref4) {
  var iconWidth = _ref4.iconWidth;
  return calculateRem(iconWidth);
}, function (_ref5) {
  var tabIndex = _ref5.tabIndex;
  return tabIndex < 0 && "\n    outline: none;\n    pointer-events: none;\n  ";
}, function (_ref6) {
  var focusState = _ref6.focusState,
      focused = _ref6.focused,
      inverted = _ref6.inverted,
      focusRadius = _ref6.focusRadius,
      borderOffset = _ref6.borderOffset;
  return focusState && focused && "\n      border: 1px dashed ".concat(inverted ? 'white' : 'black', ";\n      border-radius: ").concat(focusRadius, ";\n      padding: ").concat(borderOffset ? borderOffset : 0, ";\n  ");
}, function (_ref7) {
  var focusState = _ref7.focusState,
      focused = _ref7.focused,
      focusRadius = _ref7.focusRadius,
      borderOffset = _ref7.borderOffset;
  return focusState && !focused && "\n      border: 1px dashed transparent;\n      border-radius: ".concat(focusRadius, ";\n      padding: ").concat(borderOffset ? borderOffset : 0, ";\n  ");
});

var getStrokeWidth = function getStrokeWidth(hasStroke, medium) {
  if (!hasStroke) return 'none';

  if (medium) {
    return 2;
  } else {
    return 1;
  }
};

var getIconSize = function getIconSize(size) {
  if (typeof size === 'number') return calculateRem(size);

  switch (size) {
    case 'extraLarge':
      return 28;

    case 'large':
      return 24;

    case 'medium':
      return 20;

    case 'small':
      return 16;

    case 'extraSmall':
    default:
      return 12;
  }
};

var Icon = function Icon(props) {
  var ariaHidden = props.ariaHidden,
      name = props.name,
      size = props.size,
      lineColor = props.lineColor,
      color = props.color,
      backgroundColor = props.backgroundColor,
      inverted = props.inverted,
      data = props.data,
      hasStroke = props.hasStroke,
      medium = props.medium,
      focused = props.focused,
      focusState = props.focusState,
      focusRadius = props.focusRadius,
      borderOffset = props.borderOffset,
      id = props.id;
  var icon = data[name];
  var iconName = data[name];
  var iconColor = lineColor || color; //If inverted and no color specified

  if (inverted && !color && !lineColor) {
    iconColor = colors.white; //If inverted and color black
  } else if (inverted && (color === 'black' || color === colors.black || color === 'Black')) {
    iconColor = colors.white;
  }

  if (!icon) return null;
  return /*#__PURE__*/React.createElement(StyledSVG, {
    id: id,
    data: data,
    hasStroke: hasStroke,
    medium: medium,
    "aria-label": props.ariaLabel ? props.ariaLabel : name + ' icon',
    "aria-hidden": ariaHidden,
    tabIndex: props.tabIndex,
    "alt-text": props.ariaLabel ? props.ariaLabel : name + 'icon' //Passing rem values through to styled component keeps firefox and safari happy
    ,
    iconWidth: getIconSize(size),
    iconHeight: getIconSize(size),
    viewBox: icon.viewBox,
    backgroundColor: backgroundColor || 'transparent',
    style: props.style,
    focused: focused,
    focusState: focusState,
    inverted: inverted,
    focusRadius: focusRadius,
    borderOffset: borderOffset
  }, /*#__PURE__*/React.createElement("g", null, icon.paths.map(function (path) {
    return /*#__PURE__*/React.createElement("path", _extends({}, path['vector-effect'] && path ? {
      vectorEffect: 'non-scaling-stroke',
      stroke: iconColor,
      strokeWidth: getStrokeWidth(hasStroke, medium),
      fill: 'none'
    } : {
      stroke: 'none',
      fill: iconColor
    }, {
      key: path.d,
      d: path.d
    }));
  }), icon.circle && icon.circle.map(function (circle) {
    return /*#__PURE__*/React.createElement("circle", _extends({}, circle['vector-effect'] && circle ? {
      vectorEffect: 'non-scaling-stroke',
      stroke: iconColor,
      strokeWidth: getStrokeWidth(hasStroke, medium),
      fill: 'none'
    } : {
      stroke: 'none',
      fill: iconColor
    }, {
      key: "".concat(circle.cx).concat(circle.cy).concat(circle.r),
      cx: circle.cx,
      cy: circle.cy,
      r: circle.r
    }));
  }), icon.rect && icon.rect.map(function (rect) {
    return /*#__PURE__*/React.createElement("rect", _extends({}, rect['vector-effect'] && rect ? {
      vectorEffect: 'non-scaling-stroke',
      stroke: iconColor,
      strokeWidth: getStrokeWidth(hasStroke, medium),
      fill: 'none'
    } : {
      stroke: 'none',
      fill: iconColor
    }, {
      key: "".concat(rect.x).concat(rect.y),
      x: rect.x,
      y: rect.y,
      ry: rect.ry,
      rx: rect.rx,
      transform: rect.transform,
      width: rect.width,
      height: rect.height
    }));
  }), icon.polyline && icon.polyline.map(function (polyline) {
    return /*#__PURE__*/React.createElement("polyline", _extends({}, polyline['vector-effect'] && polyline ? {
      vectorEffect: 'non-scaling-stroke',
      stroke: iconColor,
      strokeWidth: getStrokeWidth(hasStroke, medium),
      fill: 'none'
    } : {
      stroke: 'none',
      fill: iconColor
    }, {
      key: polyline.points,
      points: polyline.points
    }));
  }), icon.line && icon.line.map(function (line) {
    return /*#__PURE__*/React.createElement("line", _extends({}, line['vector-effect'] && line ? {
      vectorEffect: 'non-scaling-stroke',
      stroke: iconColor,
      strokeWidth: getStrokeWidth(hasStroke, medium),
      fill: 'none'
    } : {
      stroke: 'none',
      fill: iconColor
    }, {
      key: "".concat(line.x1).concat(line.x2).concat(line.y1).concat(line.y2),
      x1: line.x1,
      x2: line.x2,
      y1: line.y1,
      y2: line.y2
    }));
  }), icon.polygon && icon.polygon.map(function (polygon) {
    return /*#__PURE__*/React.createElement("polygon", _extends({}, polygon['vector-effect'] && polygon ? {
      vectorEffect: 'non-scaling-stroke',
      stroke: iconColor,
      strokeWidth: getStrokeWidth(hasStroke, medium),
      fill: 'none'
    } : {
      stroke: 'none',
      fill: iconColor
    }, {
      key: polygon.points,
      points: polygon.points
    }));
  })));
};

Icon.propTypes = propTypes;
Icon.defaultProps = defaultProps;
export default Icon;