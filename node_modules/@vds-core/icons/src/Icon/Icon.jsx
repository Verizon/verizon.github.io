import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import IconData from './data.json';
import { calculateRem } from '@uie/javascript-style-helpers';
import { verizonTheme as colors } from '@vds-core/theme';

const propTypes = {
  /**
   * @ignore
   */
  ariaLabel: PropTypes.string,
  /**
   * Name of icon. Identifies which icon to render.
   */
  name: PropTypes.string.isRequired,
  /**
   * Size of the icon.
   */
  size: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  /**
   * @deprecated
   */
  lineColor: PropTypes.string, //DEPRECATED
  /**
   * Color of the icon.
   */
  color: PropTypes.string,
  /**
   * @deprecated
   * Background color of the icon.
   */
  backgroundColor: PropTypes.string,
  /**
   * @deprecated
   * Optional React Style Object that will be passed on to the SVG Tag.
   */
  style: PropTypes.object,
  /**
   * The tabIndex of the icon.
   */
  tabIndex: PropTypes.number,
  /**
   * Boolean to determine if Icon is inverted.
   */
  inverted: PropTypes.bool,
  /**
   * @ignore
   */
  data: PropTypes.object, // passes through icon data object
  /**
   * @ignore
   */
  medium: PropTypes.bool, // determines the stoke width of the icon path, if true, stoke with is 2px, otherwise it's 1px.
  /**
   * @ignore
   * Boolean to determine if Icon is focused
   */
  focused: PropTypes.bool,
  /**
   * @ignore
   * Boolean to determine if Icon should receive focus state
   */
  focusState: PropTypes.bool,
  /**
   * @ignore
   * Boolean to determine if Icon should receive focus state
   */
  focusRadius: PropTypes.string,
  /**
   * Allows a unique ID to be passed to the component.
   */
  id: PropTypes.string,
  /**
   * Hides content from assistive technology when set to true
   */
  ariaHidden: PropTypes.bool,
};

const defaultProps = {
  size: 'extraSmall',
  color: 'black',
  backgroundColor: 'transparent',
  style: undefined,
  lineColor: undefined, //DEPRECATED
  tabIndex: 0,
  inverted: false,
  // props created for 1.0
  data: IconData,
  medium: false,
  focused: false,
  focusState: false,
  focusRadius: '50%',
};

const StyledSVG = styled.svg`
  background-color: ${props => props.backgroundColor};
  display: inline-block;
  height: ${({ iconHeight }) => calculateRem(iconHeight)};
  width: ${({ iconWidth }) => calculateRem(iconWidth)};
  min-height: ${({ iconHeight }) => calculateRem(iconHeight)};
  min-width: ${({ iconWidth }) => calculateRem(iconWidth)};
  ${({ tabIndex }) =>
    tabIndex < 0 &&
    `
    outline: none;
    pointer-events: none;
  `};
  ${({ focusState, focused, inverted, focusRadius, borderOffset }) =>
    focusState &&
    focused &&
    `
      border: 1px dashed ${inverted ? 'white' : 'black'};
      border-radius: ${focusRadius};
      padding: ${borderOffset ? borderOffset : 0};
  `}
  ${({ focusState, focused, focusRadius, borderOffset }) =>
    focusState &&
    !focused &&
    `
      border: 1px dashed transparent;
      border-radius: ${focusRadius};
      padding: ${borderOffset ? borderOffset : 0};
  `}
`;

const getStrokeWidth = (hasStroke, medium) => {
  if (!hasStroke) return 'none';

  if (medium) {
    return 2;
  } else {
    return 1;
  }
};

const getIconSize = size => {
  if (typeof size === 'number') return calculateRem(size);

  switch (size) {
    case 'extraLarge':
      return 28;
    case 'large':
      return 24;
    case 'medium':
      return 20;
    case 'small':
      return 16;
    case 'extraSmall':
    default:
      return 12;
  }
};

const Icon = props => {
  const {
    ariaHidden,
    name,
    size,
    lineColor,
    color,
    backgroundColor,
    inverted,
    data,
    hasStroke,
    medium,
    focused,
    focusState,
    focusRadius,
    borderOffset,
    id,
  } = props;

  const icon = data[name];
  const iconName = data[name];
  let iconColor = lineColor || color;

  //If inverted and no color specified
  if (inverted && !color && !lineColor) {
    iconColor = colors.white;
    //If inverted and color black
  } else if (
    inverted &&
    (color === 'black' || color === colors.black || color === 'Black')
  ) {
    iconColor = colors.white;
  }
  if (!icon) return null;

  return (
    <StyledSVG
      id={id}
      data={data}
      hasStroke={hasStroke}
      medium={medium}
      aria-label={props.ariaLabel ? props.ariaLabel : name + ' icon'}
      aria-hidden={ariaHidden}
      tabIndex={props.tabIndex}
      alt-text={props.ariaLabel ? props.ariaLabel : name + 'icon'}
      //Passing rem values through to styled component keeps firefox and safari happy
      iconWidth={getIconSize(size)}
      iconHeight={getIconSize(size)}
      viewBox={icon.viewBox}
      backgroundColor={backgroundColor || 'transparent'}
      style={props.style}
      focused={focused}
      focusState={focusState}
      inverted={inverted}
      focusRadius={focusRadius}
      borderOffset={borderOffset}
    >
      <g>
        {icon.paths.map(path => {
          return (
            <path
              {...(path['vector-effect'] && path
                ? {
                    vectorEffect: 'non-scaling-stroke',
                    stroke: iconColor,
                    strokeWidth: getStrokeWidth(hasStroke, medium),
                    fill: 'none',
                  }
                : {
                    stroke: 'none',
                    fill: iconColor,
                  })}
              key={path.d}
              d={path.d}
            />
          );
        })}
        {icon.circle &&
          icon.circle.map(circle => (
            <circle
              {...(circle['vector-effect'] && circle
                ? {
                    vectorEffect: 'non-scaling-stroke',
                    stroke: iconColor,
                    strokeWidth: getStrokeWidth(hasStroke, medium),
                    fill: 'none',
                  }
                : {
                    stroke: 'none',
                    fill: iconColor,
                  })}
              key={`${circle.cx}${circle.cy}${circle.r}`}
              cx={circle.cx}
              cy={circle.cy}
              r={circle.r}
            />
          ))}
        {icon.rect &&
          icon.rect.map(rect => (
            <rect
              {...(rect['vector-effect'] && rect
                ? {
                    vectorEffect: 'non-scaling-stroke',
                    stroke: iconColor,
                    strokeWidth: getStrokeWidth(hasStroke, medium),
                    fill: 'none',
                  }
                : {
                    stroke: 'none',
                    fill: iconColor,
                  })}
              key={`${rect.x}${rect.y}`}
              x={rect.x}
              y={rect.y}
              ry={rect.ry}
              rx={rect.rx}
              transform={rect.transform}
              width={rect.width}
              height={rect.height}
            />
          ))}
        {icon.polyline &&
          icon.polyline.map(polyline => (
            <polyline
              {...(polyline['vector-effect'] && polyline
                ? {
                    vectorEffect: 'non-scaling-stroke',
                    stroke: iconColor,
                    strokeWidth: getStrokeWidth(hasStroke, medium),
                    fill: 'none',
                  }
                : {
                    stroke: 'none',
                    fill: iconColor,
                  })}
              key={polyline.points}
              points={polyline.points}
            />
          ))}
        {icon.line &&
          icon.line.map(line => (
            <line
              {...(line['vector-effect'] && line
                ? {
                    vectorEffect: 'non-scaling-stroke',
                    stroke: iconColor,
                    strokeWidth: getStrokeWidth(hasStroke, medium),
                    fill: 'none',
                  }
                : {
                    stroke: 'none',
                    fill: iconColor,
                  })}
              key={`${line.x1}${line.x2}${line.y1}${line.y2}`}
              x1={line.x1}
              x2={line.x2}
              y1={line.y1}
              y2={line.y2}
            />
          ))}
        {icon.polygon &&
          icon.polygon.map(polygon => (
            <polygon
              {...(polygon['vector-effect'] && polygon
                ? {
                    vectorEffect: 'non-scaling-stroke',
                    stroke: iconColor,
                    strokeWidth: getStrokeWidth(hasStroke, medium),
                    fill: 'none',
                  }
                : {
                    stroke: 'none',
                    fill: iconColor,
                  })}
              key={polygon.points}
              points={polygon.points}
            />
          ))}
      </g>
    </StyledSVG>
  );
};

Icon.propTypes = propTypes;
Icon.defaultProps = defaultProps;

export default Icon;
