import React, { Component } from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import cuid from 'cuid';
import { calculateRem } from '@uie/javascript-style-helpers';
import { colors } from '@vds-core/theme';
import TabPanel from './TabPanel';
import { TitleConfig, TypographyConfig } from '@vds-core/typography';
import { withVDSManager } from '@vds-core/utilities';

const propTypes = {
  /**
   * Content that will be rendered in the tabs wrapper.
   */
  children: PropTypes.node,
  /**
   * An optional callback that is called when the selectedIndex changes. Passes parameters (event, tabIndex).
   */
  onTabChange: PropTypes.func,
  /**
   * Sets the Position of Tabs Border.
   */
  linePosition: PropTypes.oneOf(['bottom', 'top', 'none']),
  /**
   * The initial Active Tab's index.
   */
  selectedIndex: PropTypes.number,
  /**
   * Sets the Position of the Active/Hover Border Accent for All Tabs.
   */
  indicatorPosition: PropTypes.oneOf(['bottom', 'top', 'none']),
  /**
   * @deprecated
   * Option to make Accent Border 100% width of All Tabs.
   */
  accentFill: PropTypes.bool,
  /**
   * Option to make Accent Border 100% width of All Tabs.
   */
  indicatorFillTab: PropTypes.bool,
  /**
   * Minimum Width for All Tabs.
   */
  minWidth: PropTypes.string,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * Rendered height of the tab.
   */
  tabHeight: PropTypes.string,
  /**
   * @deprecated
   * An optional callback that is called when the selectedIndex changes. Passes parameters (event, tabIndex).
   */
  tabChange: PropTypes.func, // DEPRECATED
  /**
   * @deprecated
   * Minimum Width for All Tabs.
   */
  minTabWidth: PropTypes.string, //DEPRECATED
  /**
   * @deprecated
   * Sets the Position of the Active/Hover Border Accent for All Tabs.
   */
  accentPosition: PropTypes.oneOf(['bottom', 'top', 'none']), //DEPRECATED
  /**
   * @deprecated
   * The initial Active Tab's index.
   */
  activeTabIndex: PropTypes.number, // DEPRECATED
  /**
   * @deprecated
   */
  borderPosition: PropTypes.oneOf(['bottom', 'top', 'none']), //DEPRECATED
  /**
   * @ignore
   */
  focusState: PropTypes.bool,
  /**
   * @ignore
   */
  minHeight: PropTypes.bool,
  /**
   * @ignore
   */
  typescale: PropTypes.string,
  /**
   * @ignore
   */
  titleConfig: PropTypes.object,
  /**
   * @ignore
   */
  colorConfig: PropTypes.object,
  /**
   * @ignore
   */
  tabIndex: PropTypes.number,
  /**
   * Allows a unique ID to be passed to the component.
   */
  id: PropTypes.string,
};

const defaultProps = {
  tabChange: undefined,
  onTabChange: undefined,
  linePosition: 'bottom',
  selectedIndex: 0,
  indicatorPosition: 'top',
  accentFill: false, // DEPRECATED
  indicatorFillTab: false,
  minWidth: undefined,
  minTabWidth: undefined,
  className: null,
  typescale: TypographyConfig.getTypescale(),
  titleConfig: TitleConfig,
  colorConfig: colors,
};

const buildBorderStyle = props => {
  const { borderPosition, linePosition, colorConfig } = props;
  let styles = '';

  if (linePosition === 'top' || borderPosition === 'top') {
    styles += `
      border-top: ${calculateRem(1)} solid ${colorConfig.coolGray3};
      border-bottom: ${calculateRem(1)} solid transparent;
    `;
  } else if (linePosition === 'bottom' || borderPosition === 'bottom') {
    styles += `
      border-top: ${calculateRem(1)} solid transparent;
      border-bottom: ${calculateRem(1)} solid ${colorConfig.coolGray3};
    `;
  }

  return styles;
};

const StyledTabList = styled.ul`
  display: flex;
  margin: 0;
  padding: 0;
  list-style-type: none;

  ${props => buildBorderStyle(props)};
`;

const TabsWrapper = styled.div``;

export class Tabs extends Component {
  constructor(props) {
    super(props);

    this.activeIndex = this.props.activeTabIndex || this.props.selectedIndex;
    // We need a set of Unique Ids to match the Tabs with the Panels
    this.uniqueIds = {};

    this.childrenElements = this.ignoreFragments(this.props.children);

    this.childrenElements.forEach((child, tabIndex) => {
      this.uniqueIds[tabIndex] = cuid().substr(-6);
      // Check for explicit setting of isActive on a Tab
      if (child.props.isActive) {
        this.activeIndex = tabIndex;
      }
    });

    if (this.childrenElements && React.Children) {
      React.Children.map(this.childrenElements, elem => {
        let activeState = elem.props.active;
        if (activeState) this.overrideActive = true;
      });
    }

    this.state = {
      activeTabIndex: this.overrideActive ? undefined : this.activeIndex,
      tabsChildren: this.childrenElements,
      uniqueIds: this.uniqueIds,
    };
  }

  componentDidUpdate(prevProps, prevState) {
    if (
      this.props.activeTabIndex !== prevProps.activeTabIndex ||
      this.props.selectedIndex !== prevProps.selectedIndex
    ) {
      let newIndex = this.props.activeTabIndex || this.props.selectedIndex;
      this.setState({ activeTabIndex: newIndex });
    }

    prevState.tabsChildren.forEach((child, index) => {
      const tabsChildren = this.ignoreFragments(this.props.children);

      /* Handle for when a tab is removed of children do not exist*/
      if (!tabsChildren || !tabsChildren[index] || !tabsChildren[index].props) {
        return;
      }

      const currentPanelContent = tabsChildren[index].props.children;
      const currentPanelLabel = tabsChildren[index].props.label;

      // TODO: look into an optimization for tabsChildren being replaced individually
      if (child.props.hide !== tabsChildren[index].props.hide) {
        this.setState({ tabsChildren });
      }

      if (child.props.label !== currentPanelLabel) {
        this.setState({ tabsChildren });
      }

      if (child.props.children !== currentPanelContent) {
        this.setState({ tabsChildren });
      }
    });
  }

  ignoreFragments = childrenArray => {
    return childrenArray.map(child => {
      if (child.type === React.Fragment) {
        return child.props.children instanceof Array
          ? child.props.children[0]
          : child.props.children;
      } else {
        return child;
      }
    });
  };

  // This function finds the First Child (Tab) that is currently visible starting with the fromIndex
  getFirstVisibleChild(fromIndex = 0) {
    let firstVisibleChildIndex = -1;
    this.state.tabsChildren.forEach((child, index) => {
      if (
        index >= fromIndex &&
        firstVisibleChildIndex === -1 &&
        !child.props.hide
      ) {
        firstVisibleChildIndex = index;
      }
    });

    return firstVisibleChildIndex;
  }

  // Set the active tab
  handleTabClick(activeTabIndex, childFunction, e) {
    if (
      typeof this.props.onTabChange !== 'undefined' &&
      this.props.onTabChange
    ) {
      this.props.onTabChange(e, activeTabIndex);
    }

    // Call optional TabChanged event callback
    if (typeof this.props.tabChange !== 'undefined' && this.props.tabChange) {
      this.props.tabChange(e, activeTabIndex);
    }

    // Call optional Child Tab Click event callback
    if (childFunction) {
      childFunction(e, activeTabIndex);
    }

    this.setState({ activeTabIndex: activeTabIndex }); // Set activeTabIndex
  }

  // Handle Visibility changes requested by a Child (Tab)
  handleChildVisibilityChange(childIndex, changeType, changeData = 1) {
    if (changeType === 'isActive') {
      if (changeData === true) {
        this.setState({ activeTabIndex: childIndex });
      }
    }

    if (
      changeType === 'hide' &&
      changeData &&
      childIndex === this.state.activeTabIndex
    ) {
      let activeTabIndex = 0;
      if (changeData === 1) {
        activeTabIndex = this.getFirstVisibleChild();
      } else if (
        changeData === 2 &&
        childIndex + 1 < this.state.tabsChildren.length
      ) {
        activeTabIndex = this.getFirstVisibleChild(childIndex);
      }

      this.overrideActive = false;
      this.setState({ activeTabIndex });
    }
  }

  // Add any Props that need to be inherited from the <Tabs/> Component
  extendTabChild(child, tabIndex) {
    const { activeTabIndex, uniqueIds } = this.state;
    const props = {};
    const _this = this;

    // Check for Explicit overrides of Tabs Properties by Child Tab Properties
    [
      'accentFill',
      'indicatorFillTab',
      'accentPosition',
      'indicatorPosition',
      'minWidth',
      'minTabWidth',
      'tabHeight',
      'focusState',
      'minHeight',
    ].forEach(prop => {
      props[prop] = this.props[prop];
      if (typeof child.props[prop] !== 'undefined') {
        props[prop] = child.props[prop];
      }
    });

    // Check for Explicit override of uniqueId on this Tab
    if (typeof child.props.uniqueId !== 'undefined') {
      uniqueIds[tabIndex] = child.props.uniqueId;
    }

    const uniqueId = uniqueIds[tabIndex];

    // Check if Child Tab is currently the Active Tab, or it had a Property change on isActive
    let calcIsActive =
      activeTabIndex !== undefined
        ? tabIndex === activeTabIndex
        : child.props.active;

    const {
      'data-analyticstrack': analyticsTrack,
      'data-track': track,
      'data-clickstream': clickStream,
    } = child.props;

    return React.cloneElement(child, {
      key: tabIndex + 1,
      onClick: this.handleTabClick.bind(_this, tabIndex, child.props.onClick),
      handleVisibilityChange: this.handleChildVisibilityChange.bind(
        _this,
        tabIndex
      ),
      isActive: calcIsActive,
      active: calcIsActive,
      hide: child.props.hide,
      accentFill: props.accentFill,
      indicatorFillTab: props.indicatorFillTab,
      accentPosition: props.accentPosition,
      indicatorPosition: props.indicatorPosition,
      minWidth: props.minWidth,
      minTabWidth: props.minTabWidth,
      tabHeight: props.tabHeight,
      focusState: props.focusState || child.props.focusState,
      minHeight: props.minHeight || child.props.minHeight,
      typescale: props.typescale,
      titleConfig: props.titleConfig,
      tabIndex: props.tabIndex,
      uniqueId,
      analyticsTrack: analyticsTrack,
      track: track,
      clickStream: clickStream,
    });
  }

  // Encapsulate <Tabs/> component API as props for <Tab/> children
  renderTabs() {
    return React.Children.map(
      this.state.tabsChildren,
      this.extendTabChild.bind(this)
    );
  }

  renderTabContent(child, contentIndex) {
    const { activeTabIndex, uniqueIds } = this.state;
    const uniqueId = uniqueIds[contentIndex];
    const label = child.props.label || uniqueId;
    const isActive = activeTabIndex === contentIndex;

    return (
      <TabPanel label={label} uniqueId={uniqueId} isHidden={!isActive}>
        {child.props.children}
      </TabPanel>
    );
  }

  // Render current active tab content
  renderActiveTabContent() {
    return React.Children.map(
      this.state.tabsChildren,
      this.renderTabContent.bind(this)
    );
  }

  render() {
    const { id, onTabChange, className, ...rest } = this.props;
    return (
      <TabsWrapper className={className}>
        <StyledTabList {...rest} id={id} role="tablist">
          {this.renderTabs()}
        </StyledTabList>
        {this.props.children && (
          <TabsWrapper>{this.renderActiveTabContent()}</TabsWrapper>
        )}
      </TabsWrapper>
    );
  }
}

Tabs.defaultProps = defaultProps;
Tabs.propTypes = propTypes;

export default withVDSManager(Tabs);
