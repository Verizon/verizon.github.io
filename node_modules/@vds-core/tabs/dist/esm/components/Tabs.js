import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _taggedTemplateLiteral from "@babel/runtime/helpers/taggedTemplateLiteral";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _templateObject2() {
  var data = _taggedTemplateLiteral([""]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  display: flex;\n  margin: 0;\n  padding: 0;\n  list-style-type: none;\n\n  ", ";\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import cuid from 'cuid';
import { calculateRem } from '@uie/javascript-style-helpers';
import { colors } from '@vds-core/theme';
import TabPanel from './TabPanel';
import { TitleConfig, TypographyConfig } from '@vds-core/typography';
import { withVDSManager } from '@vds-core/utilities';
var propTypes = {
  /**
   * Content that will be rendered in the tabs wrapper.
   */
  children: PropTypes.node,

  /**
   * An optional callback that is called when the selectedIndex changes. Passes parameters (event, tabIndex).
   */
  onTabChange: PropTypes.func,

  /**
   * Sets the Position of Tabs Border.
   */
  linePosition: PropTypes.oneOf(['bottom', 'top', 'none']),

  /**
   * The initial Active Tab's index.
   */
  selectedIndex: PropTypes.number,

  /**
   * Sets the Position of the Active/Hover Border Accent for All Tabs.
   */
  indicatorPosition: PropTypes.oneOf(['bottom', 'top', 'none']),

  /**
   * @deprecated
   * Option to make Accent Border 100% width of All Tabs.
   */
  accentFill: PropTypes.bool,

  /**
   * Option to make Accent Border 100% width of All Tabs.
   */
  indicatorFillTab: PropTypes.bool,

  /**
   * Minimum Width for All Tabs.
   */
  minWidth: PropTypes.string,

  /**
   * @ignore
   */
  className: PropTypes.string,

  /**
   * Rendered height of the tab.
   */
  tabHeight: PropTypes.string,

  /**
   * @deprecated
   * An optional callback that is called when the selectedIndex changes. Passes parameters (event, tabIndex).
   */
  tabChange: PropTypes.func,
  // DEPRECATED

  /**
   * @deprecated
   * Minimum Width for All Tabs.
   */
  minTabWidth: PropTypes.string,
  //DEPRECATED

  /**
   * @deprecated
   * Sets the Position of the Active/Hover Border Accent for All Tabs.
   */
  accentPosition: PropTypes.oneOf(['bottom', 'top', 'none']),
  //DEPRECATED

  /**
   * @deprecated
   * The initial Active Tab's index.
   */
  activeTabIndex: PropTypes.number,
  // DEPRECATED

  /**
   * @deprecated
   */
  borderPosition: PropTypes.oneOf(['bottom', 'top', 'none']),
  //DEPRECATED

  /**
   * @ignore
   */
  focusState: PropTypes.bool,

  /**
   * @ignore
   */
  minHeight: PropTypes.bool,

  /**
   * @ignore
   */
  typescale: PropTypes.string,

  /**
   * @ignore
   */
  titleConfig: PropTypes.object,

  /**
   * @ignore
   */
  colorConfig: PropTypes.object,

  /**
   * @ignore
   */
  tabIndex: PropTypes.number,

  /**
   * Allows a unique ID to be passed to the component.
   */
  id: PropTypes.string
};
var defaultProps = {
  tabChange: undefined,
  onTabChange: undefined,
  linePosition: 'bottom',
  selectedIndex: 0,
  indicatorPosition: 'top',
  accentFill: false,
  // DEPRECATED
  indicatorFillTab: false,
  minWidth: undefined,
  minTabWidth: undefined,
  className: null,
  typescale: TypographyConfig.getTypescale(),
  titleConfig: TitleConfig,
  colorConfig: colors
};

var buildBorderStyle = function buildBorderStyle(props) {
  var borderPosition = props.borderPosition,
      linePosition = props.linePosition,
      colorConfig = props.colorConfig;
  var styles = '';

  if (linePosition === 'top' || borderPosition === 'top') {
    styles += "\n      border-top: ".concat(calculateRem(1), " solid ").concat(colorConfig.coolGray3, ";\n      border-bottom: ").concat(calculateRem(1), " solid transparent;\n    ");
  } else if (linePosition === 'bottom' || borderPosition === 'bottom') {
    styles += "\n      border-top: ".concat(calculateRem(1), " solid transparent;\n      border-bottom: ").concat(calculateRem(1), " solid ").concat(colorConfig.coolGray3, ";\n    ");
  }

  return styles;
};

var StyledTabList = /*#__PURE__*/styled.ul.withConfig({
  displayName: "StyledTabList",
  componentId: "sc-1ggw8n4-0"
})(_templateObject(), function (props) {
  return buildBorderStyle(props);
});
var TabsWrapper = /*#__PURE__*/styled.div.withConfig({
  displayName: "TabsWrapper",
  componentId: "sc-1ggw8n4-1"
})(_templateObject2());
export var Tabs = /*#__PURE__*/function (_Component) {
  _inherits(Tabs, _Component);

  var _super = _createSuper(Tabs);

  function Tabs(props) {
    var _this2;

    _classCallCheck(this, Tabs);

    _this2 = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this2), "ignoreFragments", function (childrenArray) {
      return childrenArray.map(function (child) {
        if (child.type === React.Fragment) {
          return child.props.children instanceof Array ? child.props.children[0] : child.props.children;
        } else {
          return child;
        }
      });
    });

    _this2.activeIndex = _this2.props.activeTabIndex || _this2.props.selectedIndex; // We need a set of Unique Ids to match the Tabs with the Panels

    _this2.uniqueIds = {};
    _this2.childrenElements = _this2.ignoreFragments(_this2.props.children);

    _this2.childrenElements.forEach(function (child, tabIndex) {
      _this2.uniqueIds[tabIndex] = cuid().substr(-6); // Check for explicit setting of isActive on a Tab

      if (child.props.isActive) {
        _this2.activeIndex = tabIndex;
      }
    });

    if (_this2.childrenElements && React.Children) {
      React.Children.map(_this2.childrenElements, function (elem) {
        var activeState = elem.props.active;
        if (activeState) _this2.overrideActive = true;
      });
    }

    _this2.state = {
      activeTabIndex: _this2.overrideActive ? undefined : _this2.activeIndex,
      tabsChildren: _this2.childrenElements,
      uniqueIds: _this2.uniqueIds
    };
    return _this2;
  }

  _createClass(Tabs, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var _this3 = this;

      if (this.props.activeTabIndex !== prevProps.activeTabIndex || this.props.selectedIndex !== prevProps.selectedIndex) {
        var newIndex = this.props.activeTabIndex || this.props.selectedIndex;
        this.setState({
          activeTabIndex: newIndex
        });
      }

      prevState.tabsChildren.forEach(function (child, index) {
        var tabsChildren = _this3.ignoreFragments(_this3.props.children);
        /* Handle for when a tab is removed of children do not exist*/


        if (!tabsChildren || !tabsChildren[index] || !tabsChildren[index].props) {
          return;
        }

        var currentPanelContent = tabsChildren[index].props.children;
        var currentPanelLabel = tabsChildren[index].props.label; // TODO: look into an optimization for tabsChildren being replaced individually

        if (child.props.hide !== tabsChildren[index].props.hide) {
          _this3.setState({
            tabsChildren: tabsChildren
          });
        }

        if (child.props.label !== currentPanelLabel) {
          _this3.setState({
            tabsChildren: tabsChildren
          });
        }

        if (child.props.children !== currentPanelContent) {
          _this3.setState({
            tabsChildren: tabsChildren
          });
        }
      });
    }
  }, {
    key: "getFirstVisibleChild",
    // This function finds the First Child (Tab) that is currently visible starting with the fromIndex
    value: function getFirstVisibleChild() {
      var fromIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var firstVisibleChildIndex = -1;
      this.state.tabsChildren.forEach(function (child, index) {
        if (index >= fromIndex && firstVisibleChildIndex === -1 && !child.props.hide) {
          firstVisibleChildIndex = index;
        }
      });
      return firstVisibleChildIndex;
    } // Set the active tab

  }, {
    key: "handleTabClick",
    value: function handleTabClick(activeTabIndex, childFunction, e) {
      if (typeof this.props.onTabChange !== 'undefined' && this.props.onTabChange) {
        this.props.onTabChange(e, activeTabIndex);
      } // Call optional TabChanged event callback


      if (typeof this.props.tabChange !== 'undefined' && this.props.tabChange) {
        this.props.tabChange(e, activeTabIndex);
      } // Call optional Child Tab Click event callback


      if (childFunction) {
        childFunction(e, activeTabIndex);
      }

      this.setState({
        activeTabIndex: activeTabIndex
      }); // Set activeTabIndex
    } // Handle Visibility changes requested by a Child (Tab)

  }, {
    key: "handleChildVisibilityChange",
    value: function handleChildVisibilityChange(childIndex, changeType) {
      var changeData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

      if (changeType === 'isActive') {
        if (changeData === true) {
          this.setState({
            activeTabIndex: childIndex
          });
        }
      }

      if (changeType === 'hide' && changeData && childIndex === this.state.activeTabIndex) {
        var activeTabIndex = 0;

        if (changeData === 1) {
          activeTabIndex = this.getFirstVisibleChild();
        } else if (changeData === 2 && childIndex + 1 < this.state.tabsChildren.length) {
          activeTabIndex = this.getFirstVisibleChild(childIndex);
        }

        this.overrideActive = false;
        this.setState({
          activeTabIndex: activeTabIndex
        });
      }
    } // Add any Props that need to be inherited from the <Tabs/> Component

  }, {
    key: "extendTabChild",
    value: function extendTabChild(child, tabIndex) {
      var _this4 = this;

      var _this$state = this.state,
          activeTabIndex = _this$state.activeTabIndex,
          uniqueIds = _this$state.uniqueIds;
      var props = {};

      var _this = this; // Check for Explicit overrides of Tabs Properties by Child Tab Properties


      ['accentFill', 'indicatorFillTab', 'accentPosition', 'indicatorPosition', 'minWidth', 'minTabWidth', 'tabHeight', 'focusState', 'minHeight'].forEach(function (prop) {
        props[prop] = _this4.props[prop];

        if (typeof child.props[prop] !== 'undefined') {
          props[prop] = child.props[prop];
        }
      }); // Check for Explicit override of uniqueId on this Tab

      if (typeof child.props.uniqueId !== 'undefined') {
        uniqueIds[tabIndex] = child.props.uniqueId;
      }

      var uniqueId = uniqueIds[tabIndex]; // Check if Child Tab is currently the Active Tab, or it had a Property change on isActive

      var calcIsActive = activeTabIndex !== undefined ? tabIndex === activeTabIndex : child.props.active;
      var _child$props = child.props,
          analyticsTrack = _child$props['data-analyticstrack'],
          track = _child$props['data-track'],
          clickStream = _child$props['data-clickstream'];
      return /*#__PURE__*/React.cloneElement(child, {
        key: tabIndex + 1,
        onClick: this.handleTabClick.bind(_this, tabIndex, child.props.onClick),
        handleVisibilityChange: this.handleChildVisibilityChange.bind(_this, tabIndex),
        isActive: calcIsActive,
        active: calcIsActive,
        hide: child.props.hide,
        accentFill: props.accentFill,
        indicatorFillTab: props.indicatorFillTab,
        accentPosition: props.accentPosition,
        indicatorPosition: props.indicatorPosition,
        minWidth: props.minWidth,
        minTabWidth: props.minTabWidth,
        tabHeight: props.tabHeight,
        focusState: props.focusState || child.props.focusState,
        minHeight: props.minHeight || child.props.minHeight,
        typescale: props.typescale,
        titleConfig: props.titleConfig,
        tabIndex: props.tabIndex,
        uniqueId: uniqueId,
        analyticsTrack: analyticsTrack,
        track: track,
        clickStream: clickStream
      });
    } // Encapsulate <Tabs/> component API as props for <Tab/> children

  }, {
    key: "renderTabs",
    value: function renderTabs() {
      return React.Children.map(this.state.tabsChildren, this.extendTabChild.bind(this));
    }
  }, {
    key: "renderTabContent",
    value: function renderTabContent(child, contentIndex) {
      var _this$state2 = this.state,
          activeTabIndex = _this$state2.activeTabIndex,
          uniqueIds = _this$state2.uniqueIds;
      var uniqueId = uniqueIds[contentIndex];
      var label = child.props.label || uniqueId;
      var isActive = activeTabIndex === contentIndex;
      return /*#__PURE__*/React.createElement(TabPanel, {
        label: label,
        uniqueId: uniqueId,
        isHidden: !isActive
      }, child.props.children);
    } // Render current active tab content

  }, {
    key: "renderActiveTabContent",
    value: function renderActiveTabContent() {
      return React.Children.map(this.state.tabsChildren, this.renderTabContent.bind(this));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          id = _this$props.id,
          onTabChange = _this$props.onTabChange,
          className = _this$props.className,
          rest = _objectWithoutProperties(_this$props, ["id", "onTabChange", "className"]);

      return /*#__PURE__*/React.createElement(TabsWrapper, {
        className: className
      }, /*#__PURE__*/React.createElement(StyledTabList, _extends({}, rest, {
        id: id,
        role: "tablist"
      }), this.renderTabs()), this.props.children && /*#__PURE__*/React.createElement(TabsWrapper, null, this.renderActiveTabContent()));
    }
  }]);

  return Tabs;
}(Component);
Tabs.defaultProps = defaultProps;
Tabs.propTypes = propTypes;
export default withVDSManager(Tabs);