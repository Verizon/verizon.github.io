import React, { createElement, cloneElement, Component } from 'react';
import PropTypes from 'prop-types';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var performanceNow = createCommonjsModule(function (module) {
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(commonjsGlobal);


});

var root = typeof window === 'undefined' ? commonjsGlobal : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60;

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = performanceNow()
        , next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function() {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last);
            } catch(e) {
              setTimeout(function() { throw e }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id
  };

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

var raf_1 = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
};
var cancel = function() {
  caf.apply(root, arguments);
};
var polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};
raf_1.cancel = cancel;
raf_1.polyfill = polyfill;

var div = null;
var prefixes = [ 'Webkit', 'Moz', 'O', 'ms' ];

var prefixStyle = function prefixStyle (prop) {
  // re-use a dummy div
  if (!div) {
    div = document.createElement('div');
  }

  var style = div.style;

  // prop exists without prefix
  if (prop in style) {
    return prop
  }

  // borderRadius -> BorderRadius
  var titleCase = prop.charAt(0).toUpperCase() + prop.slice(1);

  // find the vendor-prefixed prop
  for (var i = prefixes.length; i >= 0; i--) {
    var name = prefixes[i] + titleCase;
    // e.g. WebkitBorderRadius or webkitBorderRadius
    if (name in style) {
      return name
    }
  }

  return false
};

/**
 * Export.
 */

var toNoCase_1 = toNoCase;

/**
 * Test whether a string is camel-case.
 */

var hasSpace = /\s/;
var hasSeparator = /(_|-|\.|:)/;
var hasCamel = /([a-z][A-Z]|[A-Z][a-z])/;

/**
 * Remove any starting case from a `string`, like camel or snake, but keep
 * spaces and punctuation that may be important otherwise.
 *
 * @param {String} string
 * @return {String}
 */

function toNoCase(string) {
  if (hasSpace.test(string)) return string.toLowerCase()
  if (hasSeparator.test(string)) return (unseparate(string) || string).toLowerCase()
  if (hasCamel.test(string)) return uncamelize(string).toLowerCase()
  return string.toLowerCase()
}

/**
 * Separator splitter.
 */

var separatorSplitter = /[\W_]+(.|$)/g;

/**
 * Un-separate a `string`.
 *
 * @param {String} string
 * @return {String}
 */

function unseparate(string) {
  return string.replace(separatorSplitter, function (m, next) {
    return next ? ' ' + next : ''
  })
}

/**
 * Camelcase splitter.
 */

var camelSplitter = /(.)([A-Z]+)/g;

/**
 * Un-camelcase a `string`.
 *
 * @param {String} string
 * @return {String}
 */

function uncamelize(string) {
  return string.replace(camelSplitter, function (m, previous, uppers) {
    return previous + ' ' + uppers.toLowerCase().split('').join(' ')
  })
}

/**
 * Export.
 */

var toSpaceCase_1 = toSpaceCase;

/**
 * Convert a `string` to space case.
 *
 * @param {String} string
 * @return {String}
 */

function toSpaceCase(string) {
  return toNoCase_1(string).replace(/[\W_]+(.|$)/g, function (matches, match) {
    return match ? ' ' + match : ''
  }).trim()
}

/**
 * Export.
 */

var toCamelCase_1 = toCamelCase;

/**
 * Convert a `string` to camel case.
 *
 * @param {String} string
 * @return {String}
 */

function toCamelCase(string) {
  return toSpaceCase_1(string).replace(/\s(\w)/g, function (matches, letter) {
    return letter.toUpperCase()
  })
}

/* The following list is defined in React's core */
var IS_UNITLESS = {
  animationIterationCount: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridColumn: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  stopOpacity: true,
  strokeDashoffset: true,
  strokeOpacity: true,
  strokeWidth: true
};

var addPxToStyle = function(name, value) {
  if(typeof value === 'number' && !IS_UNITLESS[ name ]) {
    return value + 'px';
  } else {
    return value;
  }
};

var cache = { 'float': 'cssFloat' };


function style (element, property, value) {
  var camel = cache[property];
  if (typeof camel === 'undefined') {
    camel = detect(property);
  }

  // may be false if CSS prop is unsupported
  if (camel) {
    if (value === undefined) {
      return element.style[camel]
    }

    element.style[camel] = addPxToStyle(camel, value);
  }
}

function each (element, properties) {
  for (var k in properties) {
    if (properties.hasOwnProperty(k)) {
      style(element, k, properties[k]);
    }
  }
}

function detect (cssProp) {
  var camel = toCamelCase_1(cssProp);
  var result = prefixStyle(camel);
  cache[camel] = cache[cssProp] = cache[result] = result;
  return result
}

function set () {
  if (arguments.length === 2) {
    if (typeof arguments[1] === 'string') {
      arguments[0].style.cssText = arguments[1];
    } else {
      each(arguments[0], arguments[1]);
    }
  } else {
    style(arguments[0], arguments[1], arguments[2]);
  }
}

var domCss = set;
var set_1 = set;

var get = function (element, properties) {
  if (Array.isArray(properties)) {
    return properties.reduce(function (obj, prop) {
      obj[prop] = style(element, prop || '');
      return obj
    }, {})
  } else {
    return style(element, properties || '')
  }
};
domCss.set = set_1;
domCss.get = get;

function isString(maybe) {
  return typeof maybe === 'string';
}

function returnFalse() {
  return false;
}

function getInnerWidth(el) {
  var clientWidth = el.clientWidth;

  var _getComputedStyle = getComputedStyle(el),
      paddingLeft = _getComputedStyle.paddingLeft,
      paddingRight = _getComputedStyle.paddingRight;

  return clientWidth - parseFloat(paddingLeft) - parseFloat(paddingRight);
}

function getInnerHeight(el) {
  var clientHeight = el.clientHeight;

  var _getComputedStyle = getComputedStyle(el),
      paddingTop = _getComputedStyle.paddingTop,
      paddingBottom = _getComputedStyle.paddingBottom;

  return clientHeight - parseFloat(paddingTop) - parseFloat(paddingBottom);
}

var containerStyleDefault = {
  position: 'relative',
  overflow: 'hidden',
  width: '100%',
  height: '100%'
}; // Overrides containerStyleDefault properties

var containerStyleAutoHeight = {
  height: 'auto'
};
var viewStyleDefault = {
  position: 'absolute',
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  overflow: 'scroll',
  WebkitOverflowScrolling: 'touch'
}; // Overrides viewStyleDefault properties

var viewStyleAutoHeight = {
  position: 'relative',
  top: undefined,
  left: undefined,
  right: undefined,
  bottom: undefined
};
var viewStyleUniversalInitial = {
  overflow: 'hidden',
  marginRight: 0,
  marginBottom: 0
};
var trackHorizontalStyleDefault = {
  position: 'absolute',
  height: 6
};
var trackVerticalStyleDefault = {
  position: 'absolute',
  width: 6
};
var thumbHorizontalStyleDefault = {
  position: 'relative',
  display: 'block',
  height: '100%'
};
var thumbVerticalStyleDefault = {
  position: 'relative',
  display: 'block',
  width: '100%'
};
var disableSelectStyle = {
  userSelect: 'none'
};
var disableSelectStyleReset = {
  userSelect: ''
};

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
/* eslint-disable react/prop-types */

function renderViewDefault(props) {
  return React.createElement("div", props);
}
function renderTrackHorizontalDefault(_ref) {
  var style = _ref.style,
      props = _objectWithoutProperties(_ref, ["style"]);

  var finalStyle = _objectSpread({}, style, {
    right: 2,
    bottom: 2,
    left: 2,
    borderRadius: 3
  });

  return React.createElement("div", _extends({
    style: finalStyle
  }, props));
}
function renderTrackVerticalDefault(_ref2) {
  var style = _ref2.style,
      props = _objectWithoutProperties(_ref2, ["style"]);

  var finalStyle = _objectSpread({}, style, {
    right: 2,
    bottom: 2,
    top: 2,
    borderRadius: 3
  });

  return React.createElement("div", _extends({
    style: finalStyle
  }, props));
}
function renderThumbHorizontalDefault(_ref3) {
  var style = _ref3.style,
      props = _objectWithoutProperties(_ref3, ["style"]);

  var finalStyle = _objectSpread({}, style, {
    cursor: 'pointer',
    borderRadius: 'inherit',
    backgroundColor: 'rgba(0,0,0,.2)'
  });

  return React.createElement("div", _extends({
    style: finalStyle
  }, props));
}
function renderThumbVerticalDefault(_ref4) {
  var style = _ref4.style,
      props = _objectWithoutProperties(_ref4, ["style"]);

  var finalStyle = _objectSpread({}, style, {
    cursor: 'pointer',
    borderRadius: 'inherit',
    backgroundColor: 'rgba(0,0,0,.2)'
  });

  return React.createElement("div", _extends({
    style: finalStyle
  }, props));
}

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(source, true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties$1(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose$1(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose$1(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Scrollbars =
/*#__PURE__*/
function (_Component) {
  _inherits(Scrollbars, _Component);

  function Scrollbars(props) {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Scrollbars);

    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Scrollbars)).call.apply(_getPrototypeOf2, [this, props].concat(rest)));
    _this.getScrollLeft = _this.getScrollLeft.bind(_assertThisInitialized(_this));
    _this.getScrollTop = _this.getScrollTop.bind(_assertThisInitialized(_this));
    _this.getScrollWidth = _this.getScrollWidth.bind(_assertThisInitialized(_this));
    _this.getScrollHeight = _this.getScrollHeight.bind(_assertThisInitialized(_this));
    _this.getClientWidth = _this.getClientWidth.bind(_assertThisInitialized(_this));
    _this.getClientHeight = _this.getClientHeight.bind(_assertThisInitialized(_this));
    _this.getValues = _this.getValues.bind(_assertThisInitialized(_this));
    _this.getThumbHorizontalWidth = _this.getThumbHorizontalWidth.bind(_assertThisInitialized(_this));
    _this.getThumbVerticalHeight = _this.getThumbVerticalHeight.bind(_assertThisInitialized(_this));
    _this.getScrollLeftForOffset = _this.getScrollLeftForOffset.bind(_assertThisInitialized(_this));
    _this.getScrollTopForOffset = _this.getScrollTopForOffset.bind(_assertThisInitialized(_this));
    _this.scrollLeft = _this.scrollLeft.bind(_assertThisInitialized(_this));
    _this.scrollTop = _this.scrollTop.bind(_assertThisInitialized(_this));
    _this.scrollToLeft = _this.scrollToLeft.bind(_assertThisInitialized(_this));
    _this.scrollToTop = _this.scrollToTop.bind(_assertThisInitialized(_this));
    _this.scrollToRight = _this.scrollToRight.bind(_assertThisInitialized(_this));
    _this.scrollToBottom = _this.scrollToBottom.bind(_assertThisInitialized(_this));
    _this.handleTrackMouseEnter = _this.handleTrackMouseEnter.bind(_assertThisInitialized(_this));
    _this.handleTrackMouseLeave = _this.handleTrackMouseLeave.bind(_assertThisInitialized(_this));
    _this.handleHorizontalTrackMouseDown = _this.handleHorizontalTrackMouseDown.bind(_assertThisInitialized(_this));
    _this.handleVerticalTrackMouseDown = _this.handleVerticalTrackMouseDown.bind(_assertThisInitialized(_this));
    _this.handleHorizontalThumbMouseDown = _this.handleHorizontalThumbMouseDown.bind(_assertThisInitialized(_this));
    _this.handleVerticalThumbMouseDown = _this.handleVerticalThumbMouseDown.bind(_assertThisInitialized(_this));
    _this.handleWindowResize = _this.handleWindowResize.bind(_assertThisInitialized(_this));
    _this.handleScroll = _this.handleScroll.bind(_assertThisInitialized(_this));
    _this.handleDrag = _this.handleDrag.bind(_assertThisInitialized(_this));
    _this.handleDragEnd = _this.handleDragEnd.bind(_assertThisInitialized(_this));
    _this.state = {
      didMountUniversal: false
    };
    return _this;
  }

  _createClass(Scrollbars, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.addListeners();
      this.update();
      this.componentDidMountUniversal();
    }
  }, {
    key: "componentDidMountUniversal",
    value: function componentDidMountUniversal() {
      // eslint-disable-line react/sort-comp
      var universal = this.props.universal;
      if (!universal) return;
      this.setState({
        didMountUniversal: true
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.update();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.removeListeners();
      cancel(this.requestFrame);
      clearTimeout(this.hideTracksTimeout);
      clearInterval(this.detectScrollingInterval);
    }
  }, {
    key: "getScrollLeft",
    value: function getScrollLeft() {
      if (!this.view) return 0;
      return this.view.scrollLeft;
    }
  }, {
    key: "getScrollTop",
    value: function getScrollTop() {
      if (!this.view) return 0;
      return this.view.scrollTop;
    }
  }, {
    key: "getScrollWidth",
    value: function getScrollWidth() {
      if (!this.view) return 0;
      return this.view.scrollWidth;
    }
  }, {
    key: "getScrollHeight",
    value: function getScrollHeight() {
      if (!this.view) return 0;
      return this.view.scrollHeight;
    }
  }, {
    key: "getClientWidth",
    value: function getClientWidth() {
      if (!this.view) return 0;
      return this.view.clientWidth;
    }
  }, {
    key: "getClientHeight",
    value: function getClientHeight() {
      if (!this.view) return 0;
      return this.view.clientHeight;
    }
  }, {
    key: "getValues",
    value: function getValues() {
      var _ref = this.view || {},
          _ref$scrollLeft = _ref.scrollLeft,
          scrollLeft = _ref$scrollLeft === void 0 ? 0 : _ref$scrollLeft,
          _ref$scrollTop = _ref.scrollTop,
          scrollTop = _ref$scrollTop === void 0 ? 0 : _ref$scrollTop,
          _ref$scrollWidth = _ref.scrollWidth,
          scrollWidth = _ref$scrollWidth === void 0 ? 0 : _ref$scrollWidth,
          _ref$scrollHeight = _ref.scrollHeight,
          scrollHeight = _ref$scrollHeight === void 0 ? 0 : _ref$scrollHeight,
          _ref$clientWidth = _ref.clientWidth,
          clientWidth = _ref$clientWidth === void 0 ? 0 : _ref$clientWidth,
          _ref$clientHeight = _ref.clientHeight,
          clientHeight = _ref$clientHeight === void 0 ? 0 : _ref$clientHeight;

      return {
        left: scrollLeft / (scrollWidth - clientWidth) || 0,
        top: scrollTop / (scrollHeight - clientHeight) || 0,
        scrollLeft: scrollLeft,
        scrollTop: scrollTop,
        scrollWidth: scrollWidth,
        scrollHeight: scrollHeight,
        clientWidth: clientWidth,
        clientHeight: clientHeight
      };
    }
  }, {
    key: "getThumbHorizontalWidth",
    value: function getThumbHorizontalWidth() {
      var _this$props = this.props,
          thumbSize = _this$props.thumbSize,
          thumbMinSize = _this$props.thumbMinSize;
      var _this$view = this.view,
          scrollWidth = _this$view.scrollWidth,
          clientWidth = _this$view.clientWidth;
      var trackWidth = getInnerWidth(this.trackHorizontal);
      var width = Math.ceil(clientWidth / scrollWidth * trackWidth);
      if (trackWidth === width) return 0;
      if (thumbSize) return thumbSize;
      return Math.max(width, thumbMinSize);
    }
  }, {
    key: "getThumbVerticalHeight",
    value: function getThumbVerticalHeight() {
      var _this$props2 = this.props,
          thumbSize = _this$props2.thumbSize,
          thumbMinSize = _this$props2.thumbMinSize;
      var _this$view2 = this.view,
          scrollHeight = _this$view2.scrollHeight,
          clientHeight = _this$view2.clientHeight;
      var trackHeight = getInnerHeight(this.trackVertical);
      var height = Math.ceil(clientHeight / scrollHeight * trackHeight);
      if (trackHeight === height) return 0;
      if (thumbSize) return thumbSize;
      return Math.max(height, thumbMinSize);
    }
  }, {
    key: "getScrollLeftForOffset",
    value: function getScrollLeftForOffset(offset) {
      var _this$view3 = this.view,
          scrollWidth = _this$view3.scrollWidth,
          clientWidth = _this$view3.clientWidth;
      var trackWidth = getInnerWidth(this.trackHorizontal);
      var thumbWidth = this.getThumbHorizontalWidth();
      return offset / (trackWidth - thumbWidth) * (scrollWidth - clientWidth);
    }
  }, {
    key: "getScrollTopForOffset",
    value: function getScrollTopForOffset(offset) {
      var _this$view4 = this.view,
          scrollHeight = _this$view4.scrollHeight,
          clientHeight = _this$view4.clientHeight;
      var trackHeight = getInnerHeight(this.trackVertical);
      var thumbHeight = this.getThumbVerticalHeight();
      return offset / (trackHeight - thumbHeight) * (scrollHeight - clientHeight);
    }
  }, {
    key: "scrollLeft",
    value: function scrollLeft() {
      var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (!this.view) return;
      this.view.scrollLeft = left;
    }
  }, {
    key: "scrollTop",
    value: function scrollTop() {
      var top = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (!this.view) return;
      this.view.scrollTop = top;
    }
  }, {
    key: "scrollToLeft",
    value: function scrollToLeft() {
      if (!this.view) return;
      this.view.scrollLeft = 0;
    }
  }, {
    key: "scrollToTop",
    value: function scrollToTop() {
      if (!this.view) return;
      this.view.scrollTop = 0;
    }
  }, {
    key: "scrollToRight",
    value: function scrollToRight() {
      if (!this.view) return;
      this.view.scrollLeft = this.view.scrollWidth;
    }
  }, {
    key: "scrollToBottom",
    value: function scrollToBottom() {
      if (!this.view) return;
      this.view.scrollTop = this.view.scrollHeight;
    }
  }, {
    key: "addListeners",
    value: function addListeners() {
      /* istanbul ignore if */
      if (typeof document === 'undefined' || !this.view) return;
      var view = this.view,
          trackHorizontal = this.trackHorizontal,
          trackVertical = this.trackVertical,
          thumbHorizontal = this.thumbHorizontal,
          thumbVertical = this.thumbVertical;
      view.addEventListener('scroll', this.handleScroll);
      trackHorizontal.addEventListener('mouseenter', this.handleTrackMouseEnter);
      trackHorizontal.addEventListener('mouseleave', this.handleTrackMouseLeave);
      trackHorizontal.addEventListener('mousedown', this.handleHorizontalTrackMouseDown);
      trackVertical.addEventListener('mouseenter', this.handleTrackMouseEnter);
      trackVertical.addEventListener('mouseleave', this.handleTrackMouseLeave);
      trackVertical.addEventListener('mousedown', this.handleVerticalTrackMouseDown);
      thumbHorizontal.addEventListener('mousedown', this.handleHorizontalThumbMouseDown);
      thumbVertical.addEventListener('mousedown', this.handleVerticalThumbMouseDown);
      window.addEventListener('resize', this.handleWindowResize);
    }
  }, {
    key: "removeListeners",
    value: function removeListeners() {
      /* istanbul ignore if */
      if (typeof document === 'undefined' || !this.view) return;
      var view = this.view,
          trackHorizontal = this.trackHorizontal,
          trackVertical = this.trackVertical,
          thumbHorizontal = this.thumbHorizontal,
          thumbVertical = this.thumbVertical;
      view.removeEventListener('scroll', this.handleScroll);
      trackHorizontal.removeEventListener('mouseenter', this.handleTrackMouseEnter);
      trackHorizontal.removeEventListener('mouseleave', this.handleTrackMouseLeave);
      trackHorizontal.removeEventListener('mousedown', this.handleHorizontalTrackMouseDown);
      trackVertical.removeEventListener('mouseenter', this.handleTrackMouseEnter);
      trackVertical.removeEventListener('mouseleave', this.handleTrackMouseLeave);
      trackVertical.removeEventListener('mousedown', this.handleVerticalTrackMouseDown);
      thumbHorizontal.removeEventListener('mousedown', this.handleHorizontalThumbMouseDown);
      thumbVertical.removeEventListener('mousedown', this.handleVerticalThumbMouseDown);
      window.removeEventListener('resize', this.handleWindowResize); // Possibly setup by `handleDragStart`

      this.teardownDragging();
    }
  }, {
    key: "handleScroll",
    value: function handleScroll(event) {
      var _this2 = this;

      var _this$props3 = this.props,
          onScroll = _this$props3.onScroll,
          onScrollFrame = _this$props3.onScrollFrame;
      if (onScroll) onScroll(event);
      this.update(function (values) {
        var scrollLeft = values.scrollLeft,
            scrollTop = values.scrollTop;
        _this2.viewScrollLeft = scrollLeft;
        _this2.viewScrollTop = scrollTop;
        if (onScrollFrame) onScrollFrame(values);
      });
      this.detectScrolling();
    }
  }, {
    key: "handleScrollStart",
    value: function handleScrollStart() {
      var onScrollStart = this.props.onScrollStart;
      if (onScrollStart) onScrollStart();
      this.handleScrollStartAutoHide();
    }
  }, {
    key: "handleScrollStartAutoHide",
    value: function handleScrollStartAutoHide() {
      var autoHide = this.props.autoHide;
      if (!autoHide) return;
      this.showTracks();
    }
  }, {
    key: "handleScrollStop",
    value: function handleScrollStop() {
      var onScrollStop = this.props.onScrollStop;
      if (onScrollStop) onScrollStop();
      this.handleScrollStopAutoHide();
    }
  }, {
    key: "handleScrollStopAutoHide",
    value: function handleScrollStopAutoHide() {
      var autoHide = this.props.autoHide;
      if (!autoHide) return;
      this.hideTracks();
    }
  }, {
    key: "handleWindowResize",
    value: function handleWindowResize() {
      this.update();
    }
  }, {
    key: "handleHorizontalTrackMouseDown",
    value: function handleHorizontalTrackMouseDown(event) {
      event.preventDefault();
      var target = event.target,
          clientX = event.clientX;

      var _target$getBoundingCl = target.getBoundingClientRect(),
          targetLeft = _target$getBoundingCl.left;

      var thumbWidth = this.getThumbHorizontalWidth();
      var offset = Math.abs(targetLeft - clientX) - thumbWidth / 2;
      this.view.scrollLeft = this.getScrollLeftForOffset(offset);
    }
  }, {
    key: "handleVerticalTrackMouseDown",
    value: function handleVerticalTrackMouseDown(event) {
      event.preventDefault();
      var target = event.target,
          clientY = event.clientY;

      var _target$getBoundingCl2 = target.getBoundingClientRect(),
          targetTop = _target$getBoundingCl2.top;

      var thumbHeight = this.getThumbVerticalHeight();
      var offset = Math.abs(targetTop - clientY) - thumbHeight / 2;
      this.view.scrollTop = this.getScrollTopForOffset(offset);
    }
  }, {
    key: "handleHorizontalThumbMouseDown",
    value: function handleHorizontalThumbMouseDown(event) {
      event.preventDefault();
      this.handleDragStart(event);
      var target = event.target,
          clientX = event.clientX;
      var offsetWidth = target.offsetWidth;

      var _target$getBoundingCl3 = target.getBoundingClientRect(),
          left = _target$getBoundingCl3.left;

      this.prevPageX = offsetWidth - (clientX - left);
    }
  }, {
    key: "handleVerticalThumbMouseDown",
    value: function handleVerticalThumbMouseDown(event) {
      event.preventDefault();
      this.handleDragStart(event);
      var target = event.target,
          clientY = event.clientY;
      var offsetHeight = target.offsetHeight;

      var _target$getBoundingCl4 = target.getBoundingClientRect(),
          top = _target$getBoundingCl4.top;

      this.prevPageY = offsetHeight - (clientY - top);
    }
  }, {
    key: "setupDragging",
    value: function setupDragging() {
      domCss(document.body, disableSelectStyle);
      document.addEventListener('mousemove', this.handleDrag);
      document.addEventListener('mouseup', this.handleDragEnd);
      document.onselectstart = returnFalse;
    }
  }, {
    key: "teardownDragging",
    value: function teardownDragging() {
      domCss(document.body, disableSelectStyleReset);
      document.removeEventListener('mousemove', this.handleDrag);
      document.removeEventListener('mouseup', this.handleDragEnd);
      document.onselectstart = undefined;
    }
  }, {
    key: "handleDragStart",
    value: function handleDragStart(event) {
      this.dragging = true;
      event.stopImmediatePropagation();
      this.setupDragging();
    }
  }, {
    key: "handleDrag",
    value: function handleDrag(event) {
      if (this.prevPageX) {
        var clientX = event.clientX;

        var _this$trackHorizontal = this.trackHorizontal.getBoundingClientRect(),
            trackLeft = _this$trackHorizontal.left;

        var thumbWidth = this.getThumbHorizontalWidth();
        var clickPosition = thumbWidth - this.prevPageX;
        var offset = -trackLeft + clientX - clickPosition;
        this.view.scrollLeft = this.getScrollLeftForOffset(offset);
      }

      if (this.prevPageY) {
        var clientY = event.clientY;

        var _this$trackVertical$g = this.trackVertical.getBoundingClientRect(),
            trackTop = _this$trackVertical$g.top;

        var thumbHeight = this.getThumbVerticalHeight();

        var _clickPosition = thumbHeight - this.prevPageY;

        var _offset = -trackTop + clientY - _clickPosition;

        this.view.scrollTop = this.getScrollTopForOffset(_offset);
      }

      return false;
    }
  }, {
    key: "handleDragEnd",
    value: function handleDragEnd() {
      this.dragging = false;
      this.prevPageX = this.prevPageY = 0;
      this.teardownDragging();
      this.handleDragEndAutoHide();
    }
  }, {
    key: "handleDragEndAutoHide",
    value: function handleDragEndAutoHide() {
      var autoHide = this.props.autoHide;
      if (!autoHide) return;
      this.hideTracks();
    }
  }, {
    key: "handleTrackMouseEnter",
    value: function handleTrackMouseEnter() {
      this.trackMouseOver = true;
      this.handleTrackMouseEnterAutoHide();
    }
  }, {
    key: "handleTrackMouseEnterAutoHide",
    value: function handleTrackMouseEnterAutoHide() {
      var autoHide = this.props.autoHide;
      if (!autoHide) return;
      this.showTracks();
    }
  }, {
    key: "handleTrackMouseLeave",
    value: function handleTrackMouseLeave() {
      this.trackMouseOver = false;
      this.handleTrackMouseLeaveAutoHide();
    }
  }, {
    key: "handleTrackMouseLeaveAutoHide",
    value: function handleTrackMouseLeaveAutoHide() {
      var autoHide = this.props.autoHide;
      if (!autoHide) return;
      this.hideTracks();
    }
  }, {
    key: "showTracks",
    value: function showTracks() {
      clearTimeout(this.hideTracksTimeout);
      domCss(this.trackHorizontal, {
        opacity: 1
      });
      domCss(this.trackVertical, {
        opacity: 1
      });
    }
  }, {
    key: "hideTracks",
    value: function hideTracks() {
      var _this3 = this;

      if (this.dragging) return;
      if (this.scrolling) return;
      if (this.trackMouseOver) return;
      var autoHideTimeout = this.props.autoHideTimeout;
      clearTimeout(this.hideTracksTimeout);
      this.hideTracksTimeout = setTimeout(function () {
        domCss(_this3.trackHorizontal, {
          opacity: 0
        });
        domCss(_this3.trackVertical, {
          opacity: 0
        });
      }, autoHideTimeout);
    }
  }, {
    key: "detectScrolling",
    value: function detectScrolling() {
      var _this4 = this;

      if (this.scrolling) return;
      this.scrolling = true;
      this.handleScrollStart();
      this.detectScrollingInterval = setInterval(function () {
        if (_this4.lastViewScrollLeft === _this4.viewScrollLeft && _this4.lastViewScrollTop === _this4.viewScrollTop) {
          clearInterval(_this4.detectScrollingInterval);
          _this4.scrolling = false;

          _this4.handleScrollStop();
        }

        _this4.lastViewScrollLeft = _this4.viewScrollLeft;
        _this4.lastViewScrollTop = _this4.viewScrollTop;
      }, 100);
    }
  }, {
    key: "raf",
    value: function raf(callback) {
      var _this5 = this;

      if (this.requestFrame) raf_1.cancel(this.requestFrame);
      this.requestFrame = raf_1(function () {
        _this5.requestFrame = undefined;
        callback();
      });
    }
  }, {
    key: "update",
    value: function update(callback) {
      var _this6 = this;

      this.raf(function () {
        return _this6._update(callback);
      });
    }
  }, {
    key: "_update",
    value: function _update(callback) {
      var _this$props4 = this.props,
          onUpdate = _this$props4.onUpdate,
          hideTracksWhenNotNeeded = _this$props4.hideTracksWhenNotNeeded;
      var values = this.getValues();

      {
        var scrollLeft = values.scrollLeft,
            clientWidth = values.clientWidth,
            scrollWidth = values.scrollWidth;
        var trackHorizontalWidth = getInnerWidth(this.trackHorizontal);
        var thumbHorizontalWidth = this.getThumbHorizontalWidth();
        var thumbHorizontalX = scrollLeft / (scrollWidth - clientWidth) * (trackHorizontalWidth - thumbHorizontalWidth);
        var thumbHorizontalStyle = {
          width: thumbHorizontalWidth,
          transform: "translateX(".concat(thumbHorizontalX, "px)")
        };
        var scrollTop = values.scrollTop,
            clientHeight = values.clientHeight,
            scrollHeight = values.scrollHeight;
        var trackVerticalHeight = getInnerHeight(this.trackVertical);
        var thumbVerticalHeight = this.getThumbVerticalHeight();
        var thumbVerticalY = scrollTop / (scrollHeight - clientHeight) * (trackVerticalHeight - thumbVerticalHeight);
        var thumbVerticalStyle = {
          height: thumbVerticalHeight,
          transform: "translateY(".concat(thumbVerticalY, "px)")
        };

        if (hideTracksWhenNotNeeded) {
          var trackHorizontalStyle = {
            visibility: scrollWidth > clientWidth ? 'visible' : 'hidden'
          };
          var trackVerticalStyle = {
            visibility: scrollHeight > clientHeight ? 'visible' : 'hidden'
          };
          domCss(this.trackHorizontal, trackHorizontalStyle);
          domCss(this.trackVertical, trackVerticalStyle);
        }

        domCss(this.thumbHorizontal, thumbHorizontalStyle);
        domCss(this.thumbVertical, thumbVerticalStyle);
      }

      if (onUpdate) onUpdate(values);
      if (typeof callback !== 'function') return;
      callback(values);
    }
  }, {
    key: "render",
    value: function render() {
      var _this7 = this;

      var scrollbarWidth = 15;
      /* eslint-disable no-unused-vars */

      var _this$props5 = this.props,
          onScroll = _this$props5.onScroll,
          onScrollFrame = _this$props5.onScrollFrame,
          onScrollStart = _this$props5.onScrollStart,
          onScrollStop = _this$props5.onScrollStop,
          onUpdate = _this$props5.onUpdate,
          renderView = _this$props5.renderView,
          renderTrackHorizontal = _this$props5.renderTrackHorizontal,
          renderTrackVertical = _this$props5.renderTrackVertical,
          renderThumbHorizontal = _this$props5.renderThumbHorizontal,
          renderThumbVertical = _this$props5.renderThumbVertical,
          tagName = _this$props5.tagName,
          hideTracksWhenNotNeeded = _this$props5.hideTracksWhenNotNeeded,
          autoHide = _this$props5.autoHide,
          autoHideTimeout = _this$props5.autoHideTimeout,
          autoHideDuration = _this$props5.autoHideDuration,
          thumbSize = _this$props5.thumbSize,
          thumbMinSize = _this$props5.thumbMinSize,
          universal = _this$props5.universal,
          autoHeight = _this$props5.autoHeight,
          autoHeightMin = _this$props5.autoHeightMin,
          autoHeightMax = _this$props5.autoHeightMax,
          style = _this$props5.style,
          children = _this$props5.children,
          props = _objectWithoutProperties$1(_this$props5, ["onScroll", "onScrollFrame", "onScrollStart", "onScrollStop", "onUpdate", "renderView", "renderTrackHorizontal", "renderTrackVertical", "renderThumbHorizontal", "renderThumbVertical", "tagName", "hideTracksWhenNotNeeded", "autoHide", "autoHideTimeout", "autoHideDuration", "thumbSize", "thumbMinSize", "universal", "autoHeight", "autoHeightMin", "autoHeightMax", "style", "children"]);
      /* eslint-enable no-unused-vars */


      var didMountUniversal = this.state.didMountUniversal;

      var containerStyle = _objectSpread$1({}, containerStyleDefault, {}, autoHeight && _objectSpread$1({}, containerStyleAutoHeight, {
        minHeight: autoHeightMin,
        maxHeight: autoHeightMax
      }), {}, style);

      var viewStyle = _objectSpread$1({}, viewStyleDefault, {
        // Hide scrollbars by setting a negative margin
        marginRight:  -scrollbarWidth ,
        marginBottom:  -scrollbarWidth 
      }, autoHeight && _objectSpread$1({}, viewStyleAutoHeight, {
        // Add scrollbarWidth to autoHeight in order to compensate negative margins
        minHeight: isString(autoHeightMin) ? "calc(".concat(autoHeightMin, " + ").concat(scrollbarWidth, "px)") : autoHeightMin + scrollbarWidth,
        maxHeight: isString(autoHeightMax) ? "calc(".concat(autoHeightMax, " + ").concat(scrollbarWidth, "px)") : autoHeightMax + scrollbarWidth
      }), {}, autoHeight && universal && !didMountUniversal && {
        minHeight: autoHeightMin,
        maxHeight: autoHeightMax
      }, {}, universal && !didMountUniversal && viewStyleUniversalInitial);

      var trackAutoHeightStyle = {
        transition: "opacity ".concat(autoHideDuration, "ms"),
        opacity: 0
      };

      var trackHorizontalStyle = _objectSpread$1({}, trackHorizontalStyleDefault, {}, autoHide && trackAutoHeightStyle, {}, ( universal && !didMountUniversal) && {
        display: 'none'
      });

      var trackVerticalStyle = _objectSpread$1({}, trackVerticalStyleDefault, {}, autoHide && trackAutoHeightStyle, {}, ( universal && !didMountUniversal) && {
        display: 'none'
      });

      return createElement(tagName, _objectSpread$1({}, props, {
        style: containerStyle,
        ref: function ref(_ref2) {
          _this7.container = _ref2;
        }
      }), [cloneElement(renderView({
        style: viewStyle
      }), {
        key: 'view',
        ref: function ref(_ref3) {
          _this7.view = _ref3;
        }
      }, children), cloneElement(renderTrackHorizontal({
        style: trackHorizontalStyle
      }), {
        key: 'trackHorizontal',
        ref: function ref(_ref4) {
          _this7.trackHorizontal = _ref4;
        }
      }, cloneElement(renderThumbHorizontal({
        style: thumbHorizontalStyleDefault
      }), {
        ref: function ref(_ref5) {
          _this7.thumbHorizontal = _ref5;
        }
      })), cloneElement(renderTrackVertical({
        style: trackVerticalStyle
      }), {
        key: 'trackVertical',
        ref: function ref(_ref6) {
          _this7.trackVertical = _ref6;
        }
      }, cloneElement(renderThumbVertical({
        style: thumbVerticalStyleDefault
      }), {
        ref: function ref(_ref7) {
          _this7.thumbVertical = _ref7;
        }
      }))]);
    }
  }]);

  return Scrollbars;
}(Component);
Scrollbars.propTypes = {
  onScroll: PropTypes.func,
  onScrollFrame: PropTypes.func,
  onScrollStart: PropTypes.func,
  onScrollStop: PropTypes.func,
  onUpdate: PropTypes.func,
  renderView: PropTypes.func,
  renderTrackHorizontal: PropTypes.func,
  renderTrackVertical: PropTypes.func,
  renderThumbHorizontal: PropTypes.func,
  renderThumbVertical: PropTypes.func,
  tagName: PropTypes.string,
  thumbSize: PropTypes.number,
  thumbMinSize: PropTypes.number,
  hideTracksWhenNotNeeded: PropTypes.bool,
  autoHide: PropTypes.bool,
  autoHideTimeout: PropTypes.number,
  autoHideDuration: PropTypes.number,
  autoHeight: PropTypes.bool,
  autoHeightMin: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  autoHeightMax: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  universal: PropTypes.bool,
  style: PropTypes.object,
  children: PropTypes.node
};
Scrollbars.defaultProps = {
  renderView: renderViewDefault,
  renderTrackHorizontal: renderTrackHorizontalDefault,
  renderTrackVertical: renderTrackVerticalDefault,
  renderThumbHorizontal: renderThumbHorizontalDefault,
  renderThumbVertical: renderThumbVerticalDefault,
  tagName: 'div',
  thumbMinSize: 30,
  hideTracksWhenNotNeeded: false,
  autoHide: false,
  autoHideTimeout: 1000,
  autoHideDuration: 200,
  autoHeight: false,
  autoHeightMin: 0,
  autoHeightMax: 200,
  universal: false
};

export default Scrollbars;
